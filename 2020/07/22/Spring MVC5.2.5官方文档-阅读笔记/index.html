
<!DOCTYPE html>
<html lang="zh-hans">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hexo">
    <title>Spring MVC 5.2.5官方文档 阅读笔记 - Hexo</title>
    <meta name="author" content="Yuttts">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yuttts","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"articleBody":"Spring MVC 5.2.5官方文档 阅读笔记\n官方文档https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller\n\n控制器(Controller)的实现\n控制器是应用程序逻辑的处理入口，主要负责去调用service层已经实现的服务。\n工作流程：控制器接收到用户请求并进行解析，然后将其转化为一个模型model交给视图，由视图解析器渲染成页面返回给用户。\n\n1.1. DispatcherServlet\n\n1.1.5. Processing1.DispatcherServlet按如下方式处理请求：\n\n在请求中搜索WebApplicationContext并进行绑定，将其作为控制器和进程中其他元素可以使用的属性。默认情况下，它绑定在 DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE 键下。\n将区域设置解析器绑定到请求，以便其他组件在处理请求（渲染视图、准备数据等）时可以获取区域相关的信息。如果不需要区域设置解析，则不需要区域设置解析程序。\n主题解析器绑定到请求，以便让视图等元素确定要使用哪个主题。如果不使用主题，可以忽略它。\n如果配置了multipart文件解析器，则会检查请求中该文件是不是multipart（分为多个部分连续上传）的。如果找到multiparts，则将该请求包装成一个MultipartHttpServletRequest对象，以便处理链中的其他组件对它做进一步的处理。有关multipart处理的详细信息，请参阅multipart解析器。\n为该请求查找一个合适的处理器。如果可以找到对应的处理器，则与该处理器关联的整条执行链（前处理器、后处理器、控制器等）都会被执行，以完成相应模型的准备或视图的渲染。或者，对于带注释的控制器，可以呈现响应（在HandlerAdapter中），而不是返回视图。\n如果处理器返回的是一个模型（model），那么框架将渲染相应的视图。若没有返回任何模型（可能是因为前后的处理器出于某些原因拦截了请求等，比如，安全问题），则框架不会渲染任何视图，此时认为对请求的处理可能已经由处理链完成了。\n\nContainer Error Page\n如果任何HandlerExceptionResolver仍然无法解决异常，因此，该异常将被保留以传播，或者如果响应状态设置为错误状态（即4xx、5xx），则Servlet容器可以在HTML中呈现默认的错误页。要自定义容器的默认错误页，可以在web.xml中声明错误页映射。下面的示例演示了如何执行此操作：\n\n123&lt;error-page&gt;    &lt;location&gt;/error&lt;/location&gt;&lt;/error-page&gt;\n\n在前面的示例中，当出现异常或响应具有错误状态时，Servlet容器在容器内对配置的URL进行错误分派（例如/error）。然后由DispatcherServlet进行处理，可能将其映射到@Controller，后者可以实现为返回带有模型的错误视图名称或呈现JSON响应，如下例所示：\n1234567891011@RestControllerpublic class ErrorController &#123;    @RequestMapping(path = \"/error\")    public Map&lt;String, Object&gt; handle(HttpServletRequest request) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"status\", request.getAttribute(\"javax.servlet.error.status_code\"));        map.put(\"reason\", request.getAttribute(\"javax.servlet.error.message\"));        return map;    &#125;&#125;\n\nSession Resolver\nsessionLocalerResolver允许您从可能与用户请求关联的会话中检索区域设置和时区。与CookielocalResolver不同，此策略将本地选择的区域设置存储在Servlet容器的HttpSession中。因此，这些设置是每个会话的临时设置，因此在每个会话终止时丢失。\n请注意，与外部会话管理机制（如Spring会话项目）没有直接关系。此sessionLocalerResolver根据当前HttpServletRequest计算并修改相应的HttpSession属性。\n\n1.1.11. Multipart Resolver\n来自org.springframework.web.multipart包的MultipartResolver是一种分析包括文件上传在内的多部分请求的策略。其中有一种实现基于Commons FileUpload，另一种实现基于Servlet 3.0多部分请求解析。\n\n要启用多部分处理，需要在DispatcherServlet Spring配置中使用MultipartResolver的一个名称声明MultipartResolver bean最佳。DispatcherServlet将检测到它并将其应用于传入的请求。\n当接收到内容类型为multipart/form数据的POST时，解析器解析内容并将当前HttpServletRequest包装为multiparttpservletrequest，以提供对已解析部分的访问，并将其作为请求参数公开。\n\n\nApache Commons FileUploadTo use Apache Commons FileUpload, you can configure a bean of type CommonsMultipartResolver with a name of multipartResolver. You also need to have commons-fileupload as a dependency on your classpath.\nServlet 3.0Servlet 3.0 multipart parsing needs to be enabled through Servlet container configuration. To do so:\n\nIn Java, set a MultipartConfigElement on the Servlet registration.\nIn web.xml, add a &quot;&quot; section to the servlet declaration.\n\nThe following example shows how to set a MultipartConfigElement on the Servlet registration:\n123456789101112public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    // ...    @Override    protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123;        // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold        registration.setMultipartConfig(new MultipartConfigElement(\"/tmp\"));    &#125;&#125;\n\nOnce the Servlet 3.0 configuration is in place, you can add a bean of type StandardServletMultipartResolver with a name of multipartResolver.\n1.2. Filters1.3. Annotated Controllers: @Controller @RestController1.3.1. Declaration\nSpring MVC提供了一个基于注释的编程模型，其中@Controller和@RestController组件使用注释来表示请求映射、请求输入、异常处理等。带注释的控制器具有灵活的方法识别标志，无需扩展基类或实现特定接口。\n分派器（DispatcherServlet）会自动扫描所有注解了@Controller的类，检测其中通过@RequestMapping注解配置的方法。\n\n1、自定义控制器的bean组件：\n遵循WebApplicationContext的组件标准，而且spring支持自动检测在类路径下的@Component类与自动注册bean组件。\n\n\n配置类：为了能够自动检测到控制器的bean组件，需要使用@ComponentScan：\n\n123@Configuration@ComponentScan(\"org.example.web\")public class WebConfig\n\n\nxml文件配置：\n1&lt;context:component-scan base-package=\"org.example.web\"/&gt;\n\n\n\n2、@RestController\n是@Controller和@Responsebody的结合体，一方面表明这是一个控制器，另一方面其方法继承了@Responsebody，因此该类中方法直接写入响应体，而不是通过视图解析和HTML模板呈现\n\n3、面向切面（AOP）代理@Controller控制器默认选择AOP代理，可使用@Transactional管理事务，但是在控制器需要实现特定接口【而该接口又不支持Spring Context的回调（比如InitializingBean, *Aware等接口）】的时候，则需要自行配置代理。\nFor example with  \n&lt;tx:annotation-driven/&gt;,change to &lt;tx:annotation-driven proxy-target-class=&quot;true&quot;/&gt;\n1.3.2. Request Mapping\n@RequestMapping注解默认会映射所有的HTTP请求方法。如果仅想接收某种请求方法，请在注解中指定之@RequestMapping(method=GET)以缩小范围。\n把控制器中的一系列处理方法当成是一系列独立的服务节点，每个从类级别和方法级别的@RequestMapping注解中获取到足够请求路径映射信息。【RequestMappingHandlerMapping】\n\nThere are also HTTP method specific shortcut variants of @RequestMapping:\n\n@GetMapping  该方法接受一个模型model并以字符串Sring形式返回一个视图名\n@PostMapping\n@PutMapping\n@DeleteMapping\n@PatchMapping\n\n在类级别使用@RequestMapping来表示共享映射, 再在控制器方法上使用可区别的映射方式。即classes level +method level的映射组成了一个特定的http请求路径。\n\n\n一般来说，类级别的注解负责将一个特定（或符合某种模式）的请求路径映射到一个控制器上，同时通过方法级别的注解来细化映射，即根据特定的HTTP请求方法（“GET”“POST”方法等）、HTTP请求中是否携带特定参数等条件，将请求映射到匹配的方法上。\n\n\n123456789101112131415@RestController@RequestMapping(\"/persons\")class PersonController &#123;    @GetMapping(\"/&#123;id&#125;\")    public Person getPerson(@PathVariable Long id) &#123;        // ...    &#125;    @PostMapping    @ResponseStatus(HttpStatus.CREATED)    public void add(@RequestBody Person person) &#123;        // ...    &#125;&#125;\n\nURI patterns：URI模板\nURI模板是一个类似于URI的字符串，只不过其中包含了一个或多个的变量名。当你使用实际的值去填充这些变量名的时候，模板就退化成了一个URI。即URI进行了参数化。\n\n您可以使用glob模式和通配符映射请求：\n\n?  匹配一个字符\n*匹配路径段中的零个或多个字符\n**匹配零个或多个路径段\n\n1、@PathVariable：可以声明URI变量并使用@PathVariable访问它们的值：\n\n在Spring MVC中你可以在方法参数上使用@PathVariable注解，将其与URI模板中的参数绑定起来：\n\nURI变量将自动转换为适当的类型，或者引发“TypeMismatchException”。默认情况下支持简单类型 - int、long、Date，您可以注册对任何其他数据类型的支持。请参见类型转换和绑定方法。\n\n\n\nSpring MVC可通过显式命名@PathVariables中变量名来找到URI模板中相对应的变量。 \nURI变量可以显式地命名为 - ，例如@PathVariable（“customId”）\n\n如果URI模板中的变量名与方法的参数名是相同的，则你可以不必再指定一次。\n\n一个方法可以拥有任意数量的@PathVariable注解\n\n\n\n\n\n123456789@Controller@RequestMapping(\"/owners/&#123;ownerId&#125;\")public class OwnerController &#123;  //如果URI模板中的变量名与方法的参数名是相同的，则可以不必再指定一次。    @GetMapping(\"/pets/&#123;petId&#125;\")    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;        // ...    &#125;&#125;\n\n1234@RequestMapping(path=\"/owners/&#123;ownerId&#125;&#125;\", method=RequestMethod.GET)public String findOwner(@PathVariable(\"ownerId\") String theOwner, Model model) &#123;    // 具体的方法代码…&#125;\n\n2、可以使用正则表达式声明uri变量：\n语法：{varName:regex}  第一部分定义了变量名，第二部分就是你所要应用的正则表达式\nSpring MVC使用PathMatcher契约和来自Spring core的AntPathMatcher实现进行URI路径匹配。\n下面的方法提取名称、版本和文件扩展名：\n\n1234@GetMapping(\"/&#123;name:[a-z-]+&#125;-&#123;version:\\\\d\\\\.\\\\d\\\\.\\\\d&#125;&#123;ext:\\\\.[a-z]+&#125;\")public void handle(@PathVariable String version, @PathVariable String ext) &#123;    // ...&#125;\n\n3、Pattern comparison：模式比较/路径匹配最佳匹配：This done via AntPathMatcher.getPatternComparator(String path) which looks for patterns that more specific.\n匹配顺序：\n\n即越具体 匹配分数越高，URI模板变量的数目和通配符数量的总和最少的那个路径模板更准确。\n\n匹配得分：URI变量&gt;单个通配符&gt;多个通配符&gt;前缀模式&gt;/**\n默认的映射模式 /** 不包括在评分中，并且总是最后排序。此外，前缀模式（如 /public/** ）被认为比其他任何不包括双通配符的模式更不具体。\n\n\n\n更多的细节请参考这两个类：AntPatternComparator和AntPathMatcher。值得一提的是，PathMatcher类是可以配置的。\n\n4. Suffix Match/后缀匹配\n\n默认情况下，Spring MVC采用&quot;.*&quot;的后缀模式匹配来进行路径匹配，即所有在/person路径下的的控制器会被隐式映射到/person.*。\n\n可利用不同的文件扩展名解析对应的请求内容类型（即，代替接收头）  ，以响应请求。\n例如/person.pdf、/person.xml和其他。\n当使用URI变量、路径参数和URI编码覆盖时，文件扩展名可能会导致歧义。目前首选是使用接收头，而当浏览器用来发送难以一致解释的接受头时，则可使用文件扩展名来区分解析。\n\n\n\n要完全禁用文件扩展名的使用，必须同时设置以下两项：\n\nuseSuffixPatternMatching(false), see PathMatchConfigurer\nfavorPathExtension(false), see ContentNegotiationConfigurer\n\n\n建议使用基于查询参数的策略，以避免文件扩展名带来的大多数问题。或者，如果必须使用文件扩展名，请考虑通过ContentNegotiationConfigurer的mediaTypes属性将它们限制为显式注册的扩展名列表。\n\n\n从5.2.4开始，在RequestMappingHandlerMapping中的请求映射和在ContentNegotiationManagerFactoryBean中的内容协商的路径扩展相关选项将被弃用。更多计划见Spring框架问题#24179及相关问题。\n\n5.Suffix Match and RFD/后缀模式匹配与RFD\n反射文件下载（reflected file download，RFD）攻击与XSS类似，它依赖于响应中反射的请求输入（例如，查询参数和URI变量）。然而，RFD攻击不是将JavaScript插入HTML，而是依赖于浏览器页面切换来执行下载，并在以后双击时将响应视为可执行脚本。\n在Spring MVC中，@ResponseBody和ResponseEntity方法面临风险，因为它们会根据客户的请求——包括URL的路径后缀，来渲染不同的内容类型。禁用后缀模式匹配和使用路径扩展进行内容协商可以降低风险，但不足以防止RFD攻击。\n为了防止RFD攻击，在呈现响应体之前，Spring MVC添加了一个Content-Disposition:inline;filename=f.txt  头，以指定固定的下载文件的文件名。这仅在URL路径中包含了一个文件符合以下特征的拓展名时适用：该扩展名既不在信任列表（白名单）中，也没有被显式地被注册于内容协商时使用。并且这种做法还可以有一些副作用，比如，当URL是通过浏览器手动输入的时候。\n\n默认情况下，许多公共路径扩展都是白名单。具有自定义HttpMessageConverter实现的应用程序可以显式注册用于内容协商的文件扩展名，以避免为这些扩展名添加内容处置头。请参见内容类型。有关RFD的其他建议，见CVE-2015-5211。\n\n\n6.Consumable Media Types可以根据请求的内容类型缩小请求映射范围，如下例所示：\nUsing a consumes attribute to narrow the mapping by the content type.\n1234@PostMapping(path = \"/pets\", consumes = \"application/json\") public void addPet(@RequestBody Pet pet) &#123;    // ...&#125;\n\n\nconsumes属性还支持否定表达式 - ，例如！text/plain是指除text/plain以外的任何内容类型。\n可以在类级别声明一个consumes属性。但与大多数其他请求映射属性不同，当在类级别声明consumes属性时，方法级别会进行属性重写，而不是扩展类级别声明。\nMediaType还为常用的媒体类型（如APPLICATION_JSON_VALUE和APPLICATION_XML_VALUE）提供常量。\n\n7.Producible Media Types\n与Consumable Media Types相似\n\n12345@GetMapping(path = \"/pets/&#123;petId&#125;\", produces = \"application/json\") @ResponseBodypublic Pet getPet(@PathVariable String petId) &#123;    // ...&#125;\n\n8.Parameters, headers可以基于请求参数条件缩小请求映射范围。可以检查是否存在请求参数（myParam），是否缺少一个特定值，及规定特定条件（myParam=myValue）\n1234@GetMapping(path = \"/pets/&#123;petId&#125;\", params = \"myParam=myValue\") public void findPet(@PathVariable String petId) &#123;    // ...&#125;\n\n您还可以对请求头条件使用相同的条件，如下例所示：\n1234@GetMapping(path = \"/pets\", headers = \"myHeader=myValue\") public void findPet(@PathVariable String petId) &#123;    // ...&#125;\n\n\n您可以将内容类型和Accept与headers条件匹配，但最好使用consumers和products。\n\n9.HTTP HEAD, OPTIONS / HTTP头，选项\n@GetMapping（和@RequestMapping（method=HttpMethod.GET））隐式映射到并支持HTTP HEAD。一个HTTP HEAD请求被当作HTTP GET来处理，只是不写正文，而是计算字节数并设置内容长度头。\n默认情况下，通过将Allow response头设置为所有@RequestMapping方法中列出的能够进行URL匹配的HTTP方法列表来处理HTTP选项。\n对于没有HTTP方法声明的@RequestMapping，Allow头被设置为GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS。控制器方法应始终声明受支持的HTTP方法（例如，使用HTTP方法特定的变量：@GetMapping、@PostMapping和其他变量）。\n\n\nCustom Annotations/自定义注解\n\nSpring MVC 支持使用组合注解@GetMapping、@PostMapping、@PutMapping、@DeleteMapping和@PatchMapping来执行更具体的用途。\n\n这些注释本身就是用@RequestMapping进行元注释的注释，用于重新声明@RequestMapping属性的一个子集（或全部），具有更窄、更具体的用途。\nSpring MVC还支持具有 自定义请求匹配逻辑的自定义请求映射属性，其需要子类化RequestMappingHandlerMapping并重写getCustomMethodCondition方法，可以在该方法中检查自定义属性并返回自己的RequestCondition。\n\n11.Explicit Registrations/注册处理器方法您可以以编程方式注册处理器方法，这些方法可用于动态注册或高级情况，例如不同URL下同一处理程序的不同实例。以下示例注册处理器方法：\n123456789101112131415@Configurationpublic class MyConfig &#123;//为控制器注入目标处理程序和处理程序映射。    @Autowired    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler)             throws NoSuchMethodException &#123;//准备请求映射元数据。        RequestMappingInfo info = RequestMappingInfo                .paths(\"/user/&#123;id&#125;\").methods(RequestMethod.GET).build(); //获取处理器方法。        Method method = UserHandler.class.getMethod(\"getUser\", Long.class); //添加注册。        mapping.registerMapping(info, handler, method);     &#125;&#125;\n1.3.3. Handler Methods/处理器方法1.控制器方法参数描述下表描述支持的控制器方法参数。及任何参数都不支持响应类型。\n\n\n\nController method argument\nDescription\n\n\n\nWebRequest, NativeWebRequest\nGeneric access to request parameters and request and session attributes, without direct use of the Servlet API.\n\n\njavax.servlet.ServletRequest, javax.servlet.ServletResponse\nChoose any specific request or response type — for example, ServletRequest, HttpServletRequest, or Spring’s MultipartRequest, MultipartHttpServletRequest.\n\n\njavax.servlet.http.HttpSession\nEnforces the presence of a session. As a consequence, such an argument is never null. Note that session access is not thread-safe. Consider setting the RequestMappingHandlerAdapter instance’s synchronizeOnSession flag to true if multiple requests are allowed to concurrently access a session.\n\n\njavax.servlet.http.PushBuilder\nServlet 4.0 push builder API for programmatic HTTP/2 resource pushes. Note that, per the Servlet specification, the injected PushBuilder instance can be null if the client does not support that HTTP/2 feature.\n\n\njava.security.Principal\nCurrently authenticated user — possibly a specific Principal implementation class if known.\n\n\nHttpMethod\nThe HTTP method of the request.\n\n\njava.util.Locale\nThe current request locale, determined by the most specific LocaleResolver available (in effect, the configured LocaleResolver or LocaleContextResolver).\n\n\njava.util.TimeZone + java.time.ZoneId\nThe time zone associated with the current request, as determined by a LocaleContextResolver.\n\n\njava.io.InputStream, java.io.Reader\nFor access to the raw request body as exposed by the Servlet API.\n\n\njava.io.OutputStream, java.io.Writer\nFor access to the raw response body as exposed by the Servlet API.\n\n\n@PathVariable\nFor access to URI template variables. See URI patterns.\n\n\n@MatrixVariable\nFor access to name-value pairs in URI path segments. See Matrix Variables.\n\n\n@RequestParam\nFor access to the Servlet request parameters, including multipart files. Parameter values are converted to the declared method argument type. See @RequestParam as well as Multipart.Note that use of @RequestParam is optional for simple parameter values. See “Any other argument”, at the end of this table.\n\n\n@RequestHeader\nFor access to request headers. Header values are converted to the declared method argument type. See @RequestHeader.\n\n\n@CookieValue\nFor access to cookies. Cookies values are converted to the declared method argument type. See @CookieValue.\n\n\n@RequestBody\nFor access to the HTTP request body. Body content is converted to the declared method argument type by using HttpMessageConverter implementations. See @RequestBody.\n\n\nHttpEntity\nFor access to request headers and body. The body is converted with an HttpMessageConverter. See HttpEntity.\n\n\n@RequestPart\nFor access to a part in a multipart/form-data request, converting the part’s body with an HttpMessageConverter. See Multipart.\n\n\njava.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap\nFor access to the model that is used in HTML controllers and exposed to templates as part of view rendering.\n\n\nRedirectAttributes\nSpecify attributes to use in case of a redirect (that is, to be appended to the query string) and flash attributes to be stored temporarily until the request after redirect. See Redirect Attributes and Flash Attributes.\n\n\n@ModelAttribute\nFor access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See @ModelAttribute as well as Model and DataBinder.Note that use of @ModelAttribute is optional (for example, to set its attributes). See “Any other argument” at the end of this table.\n\n\nErrors, BindingResult\nFor access to errors from validation and data binding for a command object (that is, a @ModelAttribute argument) or errors from the validation of a @RequestBody or @RequestPart arguments. You must declare an Errors, or BindingResult argument immediately after the validated method argument.\n\n\nSessionStatus + class-level @SessionAttributes\nFor marking form processing complete, which triggers cleanup of session attributes declared through a class-level @SessionAttributes annotation. See @SessionAttributes for more details.\n\n\nUriComponentsBuilder\nFor preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping. See URI Links.\n\n\n@SessionAttribute\nFor access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level @SessionAttributes declaration. See @SessionAttribute for more details.\n\n\n@RequestAttribute\nFor access to request attributes. See @RequestAttribute for more details.\n\n\nAny other argument\nIf a method argument is not matched to any of the earlier values in this table and it is a simple type (as determined by BeanUtils#isSimpleProperty, it is a resolved as a @RequestParam. Otherwise, it is resolved as a @ModelAttribute.\n\n\n2.Return Values下表描述支持的控制器方法返回值。所有返回值都支持响应类型。\n\n\n\nController method return value\nDescription\n\n\n\n@ResponseBody\nThe return value is converted through HttpMessageConverter implementations and written to the response. See @ResponseBody.\n\n\nHttpEntity, ResponseEntity\nThe return value that specifies the full response (including HTTP headers and body) is to be converted through HttpMessageConverter implementations and written to the response. See ResponseEntity.\n\n\nHttpHeaders\nFor returning a response with headers and no body.\n\n\nString\nA view name to be resolved with ViewResolver implementations and used together with the implicit model — determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (see Explicit Registrations).\n\n\nView\nA View instance to use for rendering together with the implicit model — determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (see Explicit Registrations).\n\n\njava.util.Map, org.springframework.ui.Model\nAttributes to be added to the implicit model, with the view name implicitly determined through a RequestToViewNameTranslator.\n\n\n@ModelAttribute\nAn attribute to be added to the model, with the view name implicitly determined through a RequestToViewNameTranslator.Note that @ModelAttribute is optional. See “Any other return value” at the end of this table.\n\n\nModelAndView object\nThe view and model attributes to use and, optionally, a response status.\n\n\nvoid\nA method with a void return type (or null return value) is considered to have fully handled the response if it also has a ServletResponse, an OutputStream argument, or an @ResponseStatus annotation. The same is also true if the controller has made a positive ETag or lastModified timestamp check (see Controllers for details).If none of the above is true, a void return type can also indicate “no response body” for REST controllers or a default view name selection for HTML controllers.\n\n\nDeferredResult\nProduce any of the preceding return values asynchronously from any thread — for example, as a result of some event or callback. See Asynchronous Requests and DeferredResult.\n\n\nCallable\nProduce any of the above return values asynchronously in a Spring MVC-managed thread. See Asynchronous Requests and Callable.\n\n\nListenableFuture, java.util.concurrent.CompletionStage, java.util.concurrent.CompletableFuture\nAlternative to DeferredResult, as a convenience (for example, when an underlying service returns one of those).\n\n\nResponseBodyEmitter, SseEmitter\nEmit a stream of objects asynchronously to be written to the response with HttpMessageConverter implementations. Also supported as the body of a ResponseEntity. See Asynchronous Requests and HTTP Streaming.\n\n\nStreamingResponseBody\nWrite to the response OutputStream asynchronously. Also supported as the body of a ResponseEntity. See Asynchronous Requests and HTTP Streaming.\n\n\nReactive types — Reactor, RxJava, or others through ReactiveAdapterRegistry\nAlternative to DeferredResult with multi-value streams (for example, Flux, Observable) collected to a List.For streaming scenarios (for example, text/event-stream, application/json+stream), SseEmitter and ResponseBodyEmitter are used instead, where ServletOutputStream blocking I/O is performed on a Spring MVC-managed thread and back pressure is applied against the completion of each write.See Asynchronous Requests and Reactive Types.\n\n\nAny other return value\nAny return value that does not match any of the earlier values in this table and that is a String or void is treated as a view name (default view name selection through RequestToViewNameTranslator applies), provided it is not a simple type, as determined by BeanUtils#isSimpleProperty. Values that are simple types remain unresolved.\n\n\n3.类型转换\n\n如果参数声明为字符串以外的其他值，则表示基于字符串的请求输入的某些带注释的控制器方法参数（例如@RequestParam、@RequestHeader、@PathVariable、@MatrixVariable和@CookieValue）可能需要类型转换。\n\n在这种情况下，根据配置的转换器自动应用类型转换。默认情况下，支持简单类型（int、long、Date和其他类型）。可以通过WebDataBinder（请参阅DataBinder）或通过向FormattingConversionService注册格式化程序来自定义类型转换。请参见Spring字段格式。\n3.@MatrixVariable/矩阵变量\n矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔（例如，/cars；color=red，green；year=2012）。也可以通过重复的变量名指定多个值（例如，color=red；color=green；color=blue）。\n\n如果URL预期包含矩阵变量，则控制器方法的请求映射必须使用一个URI变量来屏蔽该变量内容，并确保可以独立于矩阵变量的顺序和存在,进行成功匹配。以下示例使用矩阵变量：\n12345678// GET /pets/42;q=11;r=22@GetMapping(\"/pets/&#123;petId&#125;\")public void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;    // petId == 42    // q == 11&#125;\n\n考虑到所有路径段都可能包含矩阵变量，您有时可能需要消除矩阵变量位于对应路径变量中的歧义。下面的示例演示了如何执行此操作：\n12345678910// GET /owners/42;q=11/pets/21;q=22@GetMapping(\"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;\")public void findPet(        @MatrixVariable(name=\"q\", pathVar=\"ownerId\") int q1,        @MatrixVariable(name=\"q\", pathVar=\"petId\") int q2) &#123;    // q1 == 11    // q2 == 22&#125;\n\n可以将矩阵变量定义为可选变量，并指定默认值，如下例所示：\n要获取所有矩阵变量，可以使用多值映射，如下例所示：\n12345678910// GET /owners/42;q=11;r=12/pets/21;q=22;s=23@GetMapping(\"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;\")public void findPet(        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,        @MatrixVariable(pathVar=\"petId\") MultiValueMap&lt;String, String&gt; petMatrixVars) &#123;    // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23]    // petMatrixVars: [\"q\" : 22, \"s\" : 23]&#125;\n\n启用矩阵变量：\n\n在MVC Java配置中，需要在路径匹配中将UrlPathHelper设置为removeSemicolonContent=false。\n在MVC XML名称空间中，可以设置&lt;MVC:annotation-driven enable matrix variables=“true”/&gt;。\n\n4.@RequestParam可以使用@RequestParam注释将Servlet请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。\n1234567891011121314151617@Controller@RequestMapping(\"/pets\")public class EditPetForm &#123;    // ...    @GetMapping    //\tUsing @RequestParam to bind petId.    public String setupForm(@RequestParam(\"petId\") int petId, Model model) &#123;         Pet pet = this.clinic.loadPet(petId);        model.addAttribute(\"pet\", pet);        return \"petForm\";    &#125;    // ...&#125;\n\n\n默认情况下，使用@RequestParam的方法参数是必需的，但是您可以通过将@RequestParam的required属性设置为false 或使用java.util.optional包装声明参数 来指定方法参数是可选的。\n\n如果目标方法参数类型不是字符串，则自动应用类型转换。请参见类型转换。\n将参数类型声明为数组或列表 允许解析同一参数名的多个参数值。\n当@RequestParam注释声明为Map&lt;String，String&gt;或MultiValueMap&lt;String，String&gt;时，如果没有在注释中指定参数名，则映射将填充每个给定参数名的请求参数值。\n\n\n5.@RequestHeader6.@CookieValue7.@ModelAttribute可以对方法参数使用@ModeAttribute注释来访问模型中的属性，或者在不存在的情况下将其实例化。\n\nmodel属性还覆盖有来自HTTP Servlet请求参数的值，这些参数的名称会与字段名匹配，进行数据绑定，这样就不必处理解析和转换单个查询参数和表单字段。下面的示例演示了如何执行此操作：\n\n123@PostMapping(\"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit\")//Bind an instance of Pet.public String processSubmit(@ModelAttribute Pet pet) &#123; &#125;\n\n一般情况是使用Model类型接收数据，但也可依赖转换器&lt;String，T&gt;和URI路径变量匹配机制来接收。\n\n在下面的示例中，模型属性名称account与URI路径变量account匹配，通过默认注册的转换器&lt;String，account&gt;将字符串类型的账户号转换成account类型，完成加载：\n\n1234@PutMapping(\"/accounts/&#123;account&#125;\")public String save(@ModelAttribute(\"account\") Account account) &#123;    // ...&#125;\n\n获取Model实例后，进行数据绑定。WebDataBinder类 将Servlet请求参数名（查询参数和表单字段）与目标对象上的字段名匹配。必要时，在进行类型转换后填充匹配字段。\n\n有关数据绑定（和验证）的更多信息，请参阅 Validation。有关自定义数据绑定的详细信息，请参阅DataBinder。\n\n数据绑定可能导致错误。默认情况下，会引发BindException。但是，要检查controller方法中是否存在此类错误，可以在@ModelAttribute旁边立即添加BindingResult参数，如下例所示：\n12345678@PostMapping(\"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit\")//\tAdding a BindingResult next to the @ModelAttribute.public String processSubmit(@ModelAttribute(\"pet\") Pet pet, BindingResult result) &#123;     if (result.hasErrors()) &#123;        return \"petForm\";    &#125;    // ...&#125;\n\n在某些情况下，您可能希望访问不带数据绑定的模型属性。对于这种情况，可以将模型注入控制器并直接访问它，或者设置@modeltattribute（binding=false），如下例所示：\n12345678910111213141516@ModelAttributepublic AccountForm setUpForm() &#123;    return new AccountForm();&#125;@ModelAttributepublic Account findAccount(@PathVariable String accountId) &#123;    return accountRepository.findOne(accountId);&#125;@PostMapping(\"update\")public String update(@Valid AccountForm form, BindingResult result,        @ModelAttribute(binding=false) Account account) &#123; //Setting @ModelAttribute(binding=false).    // ...&#125;\n\n通过添加 javax.validation.Valid 注释或Spring的@Validated注释（ Bean Validation and Spring validation），可以在数据绑定后进行自动验证。下面的示例演示了如何执行此操作：\n12345678@PostMapping(\"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit\")//Validate the Pet instance.public String processSubmit(@Valid @ModelAttribute(\"pet\") Pet pet, BindingResult result) &#123;     if (result.hasErrors()) &#123;        return \"petForm\";    &#125;    // ...&#125;\n\n\n\n8.@SessionAttributes9.@SessionAttribute10.@RequestAttribute11.Redirect Attributes/重定向属性\n默认情况下，所有模型属性都被视为重定向URL中的URI模板变量。其余的属性中，那些是基元类型或基元类型的集合或数组的属性将自动附加为查询参数。\n如果模型实例是专门为重定向准备的，则将基元类型属性作为查询参数追加可能是所需的结果。但是，在带注释的控制器中，模型可以包含为渲染目的添加的其他属性（例如，下拉字段值）。为了避免在URL中出现这样的属性，@RequestMapping方法可以声明一个类型为RedirectAttributes的参数，并使用它指定可用于RedirectView的确切属性。如果方法确实重定向，则使用RedirectAttributes的内容。否则，将使用模型的内容。\nRequestMappingHandlerAdapter提供了一个名为ignoreDefaultModelOnRedirect的标志，您可以使用该标志指示如果控制器方法重定向，则不应使用默认模型的内容。相反，controller方法应该声明一个类型为RedirectAttributes的属性，或者，如果它没有这样做，则不应该将任何属性传递给RedirectView。MVC名称空间和MVC Java配置都将此标志设置为false，以保持向后兼容性。但是，对于新应用程序，我们建议将其设置为true。\n请注意，当前请求中的URI模板变量在展开重定向URL时自动可用，您不需要通过Model或RedirectAttributes显式添加它们。下面的示例演示如何定义重定向：\n\n123456@PostMapping(\"/files/&#123;path&#125;\")public String upload(...) &#123;    // ...    return \"redirect:files/&#123;path&#125;\";&#125;Another way\n\n将数据传递到重定向目标的另一种方法是使用flash属性。与其他重定向属性不同，flash属性保存在HTTP会话中（因此不会出现在URL中）。有关详细信息，请参见Flash属性。\n12.Flash Attributes\nFlash属性为一个请求提供了一种方法来存储打算在另一个请求中使用的属性。这是重定向 - 时最常用的方法，例如，Post Redirect Get模式。Flash属性在重定向之前（通常在会话中）被临时保存，以便在重定向之后对请求可用，并立即被删除。\nSpring MVC有两个主要的抽象来支持flash属性。FlashMap用于保存flash属性，而FlashMapManager用于存储、检索和管理FlashMap实例。\nFlash属性支持始终为“on”，不需要显式启用。但是，如果不使用，它永远不会导致创建HTTP会话。对于每个请求，都有一个“input”FlashMap，其中包含从上一个请求（如果有的话）传递的属性，还有一个“output”FlashMap，其中包含要为后续请求保存的属性。这两个FlashMap实例都可以从Spring MVC的任何地方通过requestcontexttils中的静态方法访问。\n带注释的控制器通常不需要直接使用FlashMap。相反，@RequestMapping方法可以接受redirect attributes类型的参数，并使用它为重定向场景添加flash属性。通过RedirectAttributes添加的Flash属性会自动传播到“output”FlashMap。类似地，重定向之后，“input”FlashMap中的属性会自动添加到为目标URL服务的控制器模型中。\n\n\n将请求与flash属性匹配\nflash属性的概念存在于许多其他web框架中，并被证明有时会暴露在并发性问题中。这是因为，根据定义，flash属性将存储到下一个请求。但是，“下一个”请求可能不是预期的接收者，而是另一个异步请求（例如，轮询或资源请求），在这种情况下，flash属性被过早删除。\n为了减少此类问题的可能性，RedirectView会使用目标重定向URL的路径和查询参数自动“标记”FlashMap实例。反过来，默认的FlashMapManager在查找“input”FlashMap时会将该信息与传入的请求相匹配。\n这并不能完全消除并发问题的可能性，但是通过重定向URL中已有的信息可以大大降低并发问题的可能性。因此，我们建议您主要在重定向场景中使用flash属性。\n\n13.Multipart启用MultipartResolver后，将解析带有multipart/form数据的POST请求的内容，并将其作为常规请求参数进行访问。以下示例访问一个常规表单字段和一个上载文件：\n123456789101112131415@Controllerpublic class FileUploadController &#123;    @PostMapping(\"/form\")    public String handleFormUpload(@RequestParam(\"name\") String name,            @RequestParam(\"file\") MultipartFile file) &#123;//将参数类型声明为List&lt;MultipartFile&gt;允许解析同一参数名的多个文件。        if (!file.isEmpty()) &#123;            byte[] bytes = file.getBytes();            // store the bytes somewhere            return \"redirect:uploadSuccess\";        &#125;        return \"redirect:uploadFailure\";    &#125;&#125;\n\n\n当@RequestParam注释声明为Map&lt;String，MultipartFile&gt;或MultiValueMap&lt;String，MultipartFile&gt;时，如果没有在注释中指定参数名，则会使用MultipartFile的参数名填充映射。\n\n\n对于Servlet3.0多部分解析，您还可以使用javax.Servlet.http.Part代替Spring的MultipartFile，声明方法参数或集合值类型。\n\n您还可以将多部分内容用作到命令对象的数据绑定的一部分。例如，上例中的表单字段和文件可以是表单对象上的字段，如下例所示：\n12345678910111213141516171819202122class MyForm &#123;    private String name;    private MultipartFile file;    // ...&#125;@Controllerpublic class FileUploadController &#123;    @PostMapping(\"/form\")    public String handleFormUpload(MyForm form, BindingResult errors) &#123;        if (!form.getFile().isEmpty()) &#123;            byte[] bytes = form.getFile().getBytes();            // store the bytes somewhere            return \"redirect:uploadSuccess\";        &#125;        return \"redirect:uploadFailure\";    &#125;&#125;\n\n在RESTful服务场景中，也可以从非浏览器客户端提交多部分请求。以下示例显示了一个带有JSON数据的文件：\n12345678910111213141516POST /someUrlContent-Type: multipart/mixed--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7VpContent-Disposition: form-data; name=\"meta-data\"Content-Type: application/json; charset=UTF-8Content-Transfer-Encoding: 8bit&#123;    \"name\": \"value\"&#125;--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7VpContent-Disposition: form-data; name=\"file-data\"; filename=\"file.properties\"Content-Type: text/xmlContent-Transfer-Encoding: 8bit... File Data ...\n\n您可以使用@RequestParam作为字符串访问“元数据”部分，但您可能希望它从JSON反序列化（类似于@RequestBody）。使用HttpMessageConverter转换多部分后，使用@RequestPart注释访问该多部分：\n12345@PostMapping(\"/\")public String handle(@RequestPart(\"meta-data\") MetaData metadata,        @RequestPart(\"file-data\") MultipartFile file) &#123;    // ...&#125;\n\n您可以将@RequestPart与javax.validation.Valid结合使用，也可以使用Spring的@Validated注释，这两种注释都会应用标准Bean验证。默认情况下，验证错误会导致MethodArgumentNotValidException，该异常将转换为400（错误的请求）响应。或者，可以通过errors或BindingResult参数在控制器内本地处理验证错误，如下例所示：\n12345@PostMapping(&quot;&#x2F;&quot;)public String handle(@Valid @RequestPart(&quot;meta-data&quot;) MetaData metadata,        BindingResult result) &#123;    &#x2F;&#x2F; ...&#125;\n\n14.@RequestBody可以使用@RequestBody注释通过HttpMessageConverter将请求体读取并反序列化为对象。以下示例使用@RequestBody参数：\n1234@PostMapping(\"/accounts\")public void handle(@RequestBody Account account) &#123;    // ...&#125;\n\n\n可以使用MVC配置的消息转换器选项来配置或自定义消息转换。\n可以将@RequestBody与javax.validation.Valid或Spring的@Validated注释结合使用，这两种方法都会应用标准Bean验证。默认情况下，验证错误会导致MethodArgumentNotValidException，该异常将转换为400（错误的请求）响应。或者，可以通过errors或BindingResult参数在控制器内本地处理验证错误，如下例所示：\n\n1234@PostMapping(\"/accounts\")public void handle(@Valid @RequestBody Account account, BindingResult result) &#123;    // ...&#125;\n\n15.HttpEntityHttpEntity或多或少与使用@RequestBody相同，但它基于公开请求头和主体的容器对象。下面的列表显示了一个示例：\n1234@PostMapping(\"/accounts\")public void handle(HttpEntity&lt;Account&gt; entity) &#123;    // ...&#125;\n\n\n\n16.@ResponseBody可以对方法使用@ResponseBody注释，通过HttpMessageConverter将其序列化结果返回到响应体。下面的列表显示了一个示例：\n12345@GetMapping(\"/accounts/&#123;id&#125;\")@ResponseBodypublic Account handle() &#123;    // ...&#125;\n\n@ResponseBody可以在类级别使用，在这种情况下，它由所有控制器方法继承。这就是@RestController，一个@Controller和@ResponseBody的组合注释。\n\n可以将@ResponseBody与反应类型【reactive types】一起使用。有关更多详细信息，请参阅异步请求和响应类型。\n可以使用MVC配置的消息转换器选项来配置或自定义消息转换。\n可以将@ResponseBody方法与JSON序列化视图结合起来。有关详细信息，请参见Jackson JSON。\n\n17.ResponseEntityResponseEntity类似于@ResponseBody，但带有状态和标题。例如：\n123456@GetMapping(\"/something\")public ResponseEntity&lt;String&gt; handle() &#123;    String body = ... ;    String etag = ... ;    return ResponseEntity.ok().eTag(etag).build(body);&#125;\n\nSpring MVC支持使用单值反应类型 异步生成响应，和/或为主体生成单值和多值反应类型。\n18.Jackson JSON\nSpring提供了对Jackson JSON库的支持。\n\n18.1 JSON ViewsSpring MVC为Jackson的序列化视图提供了内置支持，它只允许呈现对象中所有字段的子集。要将其与@ResponseBody或ResponseEntity控制器方法一起使用，可以使用Jackson的@JsonView注释激活序列化视图类，如下例所示：\n123456789101112131415161718192021222324252627282930313233343536@RestControllerpublic class UserController &#123;    @GetMapping(\"/user\")    @JsonView(User.WithoutPasswordView.class)//使用Jackson的@JsonView注释激活序列化视图类    public User getUser() &#123;        return new User(\"eric\", \"7!jd#h23\");    &#125;&#125;public class User &#123;    public interface WithoutPasswordView &#123;&#125;;    public interface WithPasswordView extends WithoutPasswordView &#123;&#125;;    private String username;    private String password;    public User() &#123;    &#125;    public User(String username, String password) &#123;        this.username = username;        this.password = password;    &#125;    @JsonView(WithoutPasswordView.class)//使用Jackson的@JsonView注释激活序列化视图类    public String getUsername() &#123;        return this.username;    &#125;    @JsonView(WithPasswordView.class)//使用Jackson的@JsonView注释激活序列化视图类    public String getPassword() &#123;        return this.password;    &#125;&#125;\n\n\n@JsonView允许视图类数组，但每个控制器方法只能指定一个。如果需要激活多个视图，可以使用复合界面。\n\n对于依赖视图解析的控制器，可以将序列化视图类添加到模型中，如下例所示：\n1234567891011@Controllerpublic class UserController extends AbstractController &#123;    @GetMapping(\"/user\")    public String getUser(Model model) &#123;        model.addAttribute(\"user\", new User(\"eric\", \"7!jd#h23\"));        //对于依赖视图解析的控制器，可以将**序列化视图类添加到模型**中        model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);        return \"userView\";    &#125;&#125;\n\n\n\n1.3.4. Model可以使用@ModeltAttribute注释：\n\n在@RequestMapping方法中的方法参数上创建或访问模型中的对象，并通过WebDataBinder将其绑定到请求。\n作为@Controller或@ControllerAdvice类中的方法级注释，有助于在调用任何@RequestMapping方法之前初始化模型。\n在@RequestMapping方法上，标记其返回值的是一个model属性。\n\n本节讨论前面列表中的第二项@ModelAttribute methods。\n@ModelAttribute方法也可以通过@ControllerAdvice在控制器之间共享。有关更多详细信息，请参阅控制器建议部分。@ModelAttribute方法具有灵活的方法签名。除了@ModeltAttribute本身或任何与请求体相关的参数, 它们支持许多与@RequestMapping方法相同的参数以下示例显示@ModelAttribute方法：\n\n控制器可以有任意数量的@ModelAttribute方法。所有这些方法都在同一控制器中的@RequestMapping方法之前调用。@ModelAttribute方法也可以通过@ControllerAdvice在控制器之间共享。有关更多详细信息，请参阅控制器建议部分。\n\n@ModelAttribute方法具有灵活的方法签名。除了@modeltattribute本身或任何与请求体相关的参数。，它们还支持许多与@RequestMapping方法相同的参数。\n\n\n以下示例显示@ModelAttribute方法：\n12345@ModelAttributepublic void populateModel(@RequestParam String number, Model model) &#123;    model.addAttribute(accountRepository.findAccount(number));    // add more ...&#125;\n\n以下示例仅添加一个属性：\n1234@ModelAttributepublic Account addAccount(@RequestParam String number) &#123;    return accountRepository.findAccount(number);&#125;\n\n\n如果未显式指定名称，则根据对象类型选择默认名称，如javadoc for Conventions中所述。始终可以通过使用重载的addAttribute方法或通过@ModeltAttribute上的name属性（返回值）指定显式名称。\n\n\n还可以使用@ModeltAttribute作为@RequestMapping方法的方法级注释，在这种情况下，@RequestMapping方法的返回值被解释为模型属性。这通常不是必需的，因为这是HTML控制器中的默认行为，除非返回值是一个字符串，否则将被解释为视图名称。@ModelAttribute还可以自定义模型属性名称，如下例所示：\n\n123456@GetMapping(\"/accounts/&#123;id&#125;\")@ModelAttribute(\"myAccount\")//@ModelAttribute还可以自定义模型属性名称public Account handle() &#123;    // ...    return account;&#125;\n\n1.3.5. DataBinder@Controller或@ControllerAdvice类可以有@InitBinder方法来初始化WebDataBinder实例，而这些方法反过来又可以：\n\n将请求参数（即表单或查询数据）绑定到模型对象。\n将基于字符串的请求值（例如请求参数、路径变量、头、cookies和其他）转换为控制器方法参数的目标类型。\n在呈现HTML表单时，将模型对象值格式化为字符串值。\n\n123456789101112@Controllerpublic class FormController &#123;    @InitBinder //Defining an @InitBinder method.    public void initBinder(WebDataBinder binder) &#123;        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");        dateFormat.setLenient(false);        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));    &#125;    // ...&#125;\n\n\n\n12345678910@Controllerpublic class FormController &#123;    @InitBinder //在自定义格式化程序上定义@InitBinder方法。    protected void initBinder(WebDataBinder binder) &#123;        binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\"));    &#125;    // ...&#125;\n\n\n\n1.3.6. Exceptions@Controller和@ControllerAdvice类可以有@ExceptionHandler方法来处理来自Controller方法的异常，如下例所示：\n12345678910@Controllerpublic class SimpleController &#123;    // ...    @ExceptionHandler    public ResponseEntity&lt;String&gt; handle(IOException ex) &#123;        // ...    &#125;&#125;\n\n或者，注释声明可以缩小要匹配的异常类型的范围，如下例所示：\n1234@ExceptionHandler(&#123;FileSystemException.class, RemoteException.class&#125;)public ResponseEntity&lt;String&gt; handle(IOException ex) &#123;    // ...&#125;\n\n您甚至可以使用具有通用的参数签名的特定异常类型，如下例所示：\n1234@ExceptionHandler(&#123;FileSystemException.class, RemoteException.class&#125;)public ResponseEntity&lt;String&gt; handle(Exception ex) &#123;    // ...&#125;\n\n1.3.7. Controller Advice通常，@ExceptionHandler、@InitBinder和@ModelAttribute方法应用于声明它们的@Controller类（或类层次结构）中。如果您希望这些方法在全局范围内（跨控制器）应用得更多，可以在用@ControllerAdvice或@RestControllerAdvice注释的类中声明它们。\n\n@ControllerAdvice用@Component注释，这意味着可以通过组件扫描将这些类注册为springbean。\n@RestControllerAdvice是一个组合注释，它使用@ControllerAdvice和@ResponseBody进行注释，这实际上意味着@ExceptionHandler方法通过消息转换（相对于视图解析或模板呈现）呈现到响应体。\n启动时，@RequestMapping和@ExceptionHandler方法的基础结构类会检测用@ControllerAdvice注释的springbean，然后在运行时应用它们的方法。全局@ExceptionHandler方法（来自@ControllerAdvice）在本地方法（来自@Controller）之后应用。相反，全局@ModelAttribute和@InitBinder方法在本地方法之前应用。\n\n默认情况下，@ControllerAdvice方法应用于每个请求（即，所有控制器），但您可以使用注解上的属性将其缩小到控制器的子集，如下例所示：\n1234567891011// Target all Controllers annotated with @RestController@ControllerAdvice(annotations = RestController.class)public class ExampleAdvice1 &#123;&#125;// Target all Controllers within specific packages@ControllerAdvice(\"org.example.controllers\")public class ExampleAdvice2 &#123;&#125;// Target all Controllers assignable to specific classes@ControllerAdvice(assignableTypes = &#123;ControllerInterface.class, AbstractController.class&#125;)public class ExampleAdvice3 &#123;&#125;\n\n1.4. Functional Endpoints1.10. View Technologies\n在Spring MVC中使用视图技术是可插入的，无论您决定使用Thymeleaf、Groovy标记模板、jsp还是其他技术，这主要取决于配置更改。本章介绍与Spring MVC集成的视图技术。我们假设您已经熟悉视图分辨率。\n\n1.10.1. Thymeleaf\nThymeleaf是一个现代的服务器端Java模板引擎，它提倡通过双击在浏览器中预览自然HTML模板，这对于在不需要运行服务器的情况下独立处理UI模板（例如，由设计器）非常有帮助。Thymeleaf提供了一组最广泛的功能，去转换jsp页面。有关更完整的介绍，请参见Thymeleaf项目主页。\nThymeleaf与Spring MVC的集成由Thymeleaf项目管理。该配置涉及几个bean声明，如ServletContextTemplateResolver、SpringTemplateEngine和ThymeleafViewResolver。有关更多详细信息，请参见Thymeleaf+Spring。\n\n1.10.2. FreeMarkerForm Handling如果希望应用程序通过内部代码（例如）处理城市，则可以使用适当的键创建代码映射，如下例所示：\n12345678910protected Map&lt;String, ?&gt; referenceData(HttpServletRequest request) throws Exception &#123;    Map&lt;String, String&gt; cityMap = new LinkedHashMap&lt;&gt;();    cityMap.put(\"LDN\", \"London\");    cityMap.put(\"PRS\", \"Paris\");    cityMap.put(\"NYC\", \"New York\");    Map&lt;String, Object&gt; model = new HashMap&lt;&gt;();    model.put(\"cityMap\", cityMap);    return model;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHTTP 协议中 URI 和 URL 有什么区别？URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL\n\nURI = Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。\nURL = Universal Resource Locator 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol、host、port、path、parameter、anchor。\nURN = Universal Resource Name 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。\n\n\n假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。而URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI。\n\n","dateCreated":"2020-07-22T19:42:31+08:00","dateModified":"2020-07-22T22:25:17+08:00","datePublished":"2020-07-22T19:42:31+08:00","description":"Spring MVC 5.2.5官方文档 阅读笔记\n官方文档https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller\n\n控制器(Controller)的实现\n控制器是应用程序逻辑的处理入口，主要负责去调用service层已经实现的服务。\n工作流程：控制器接收到用户请求并进行解析，然后将其转化为一个模型model交给视图，由视图解析器渲染成页面返回给用户。\n\n1.1. DispatcherServlet","headline":"Spring MVC 5.2.5官方文档 阅读笔记","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"Yuttts","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"url":"https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","keywords":"SpringMVC"}</script>
    <meta name="description" content="Spring MVC 5.2.5官方文档 阅读笔记 官方文档https:&#x2F;&#x2F;docs.spring.io&#x2F;spring&#x2F;docs&#x2F;current&#x2F;spring-framework-reference&#x2F;web.html#mvc-controller  控制器(Controller)的实现 控制器是应用程序逻辑的处理入口，主要负责去调用service层已经实现的服务。 工作流程：控制器接收到用户请求并">
<meta property="og:type" content="blog">
<meta property="og:title" content="Spring MVC 5.2.5官方文档 阅读笔记">
<meta property="og:url" content="https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Spring MVC 5.2.5官方文档 阅读笔记 官方文档https:&#x2F;&#x2F;docs.spring.io&#x2F;spring&#x2F;docs&#x2F;current&#x2F;spring-framework-reference&#x2F;web.html#mvc-controller  控制器(Controller)的实现 控制器是应用程序逻辑的处理入口，主要负责去调用service层已经实现的服务。 工作流程：控制器接收到用户请求并">
<meta property="article:published_time" content="2020-07-22T11:42:31.519Z">
<meta property="article:modified_time" content="2020-07-22T14:25:17.996Z">
<meta property="article:author" content="Yuttts">
<meta property="article:tag" content="SpringMVC">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/%20"
            aria-label=""
        >
            Hexo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Abre el enlace: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Inicio"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Inicio</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categorías"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categorías</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Etiquetas"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Etiquetas</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archivos"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archivos</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Buscar"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Buscar</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="Acerca de"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Acerca de</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="http://stackoverflow.com/users"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://facebook.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://plus.google.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Google Plus"
                        >
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google Plus</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="Correo"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Correo</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Spring MVC 5.2.5官方文档 阅读笔记
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-07-22T19:42:31+08:00">
	
		    22 Jul 2020
    	
    </time>
    
        <span>en </span>
        
    <a class="category-link" href="/categories/Spring/">Spring</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h1 id="Spring-MVC-5-2-5官方文档-阅读笔记"><a href="#Spring-MVC-5-2-5官方文档-阅读笔记" class="headerlink" title="Spring MVC 5.2.5官方文档 阅读笔记"></a>Spring MVC 5.2.5官方文档 阅读笔记</h1><blockquote>
<p>官方文档<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller</a></p>
</blockquote>
<h2 id="控制器-Controller-的实现"><a href="#控制器-Controller-的实现" class="headerlink" title="控制器(Controller)的实现"></a>控制器(Controller)的实现</h2><blockquote>
<p>控制器是应用程序逻辑的处理入口，主要负责去调用service层已经实现的服务。</p>
<p>工作流程：控制器接收到用户请求并进行解析，然后将其转化为一个模型model交给视图，由视图解析器渲染成页面返回给用户。</p>
</blockquote>
<h3 id="1-1-DispatcherServlet"><a href="#1-1-DispatcherServlet" class="headerlink" title="1.1. DispatcherServlet"></a>1.1. DispatcherServlet</h3><a id="more"></a>

<h4 id="1-1-5-Processing"><a href="#1-1-5-Processing" class="headerlink" title="1.1.5. Processing"></a>1.1.5. Processing</h4><p><strong>1.DispatcherServlet按如下方式处理请求：</strong></p>
<ol>
<li>在请求中搜索WebApplicationContext并进行绑定，将其作为控制器和进程中其他元素可以使用的属性。默认情况下，它绑定在 DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE 键下。</li>
<li>将区域设置解析器绑定到请求，以便其他组件在处理请求（渲染视图、准备数据等）时可以获取区域相关的信息。如果不需要区域设置解析，则不需要区域设置解析程序。</li>
<li>主题解析器绑定到请求，以便让视图等元素确定要使用哪个主题。如果不使用主题，可以忽略它。</li>
<li>如果配置了multipart文件解析器，则会检查请求中该文件是不是multipart（分为多个部分连续上传）的。如果找到multiparts，则将该请求包装成一个<code>MultipartHttpServletRequest</code>对象，以便处理链中的其他组件对它做进一步的处理。有关multipart处理的详细信息，请参阅multipart解析器。</li>
<li>为该请求查找一个合适的处理器。如果可以找到对应的处理器，则与该处理器关联的整条执行链（前处理器、后处理器、控制器等）都会被执行，以完成相应模型的准备或视图的渲染。或者，对于带注释的控制器，可以呈现响应（在HandlerAdapter中），而不是返回视图。</li>
<li>如果处理器返回的是一个模型（model），那么框架将渲染相应的视图。若没有返回任何模型（可能是因为前后的处理器出于某些原因拦截了请求等，比如，安全问题），则框架不会渲染任何视图，此时认为对请求的处理可能已经由处理链完成了。</li>
</ol>
<h5 id="Container-Error-Page"><a href="#Container-Error-Page" class="headerlink" title="Container Error Page"></a>Container Error Page</h5><blockquote>
<p>如果任何HandlerExceptionResolver仍然无法解决异常，因此，该异常将被保留以传播，或者如果响应状态设置为错误状态（即4xx、5xx），则Servlet容器可以在HTML中呈现默认的错误页。要自定义容器的默认错误页，可以在web.xml中声明错误页映射。下面的示例演示了如何执行此操作：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在前面的示例中，当出现异常或响应具有错误状态时，Servlet容器在容器内对配置的URL进行错误分派（例如/error）。然后由DispatcherServlet进行处理，可能将其映射到@Controller，后者可以实现为返回带有模型的错误视图名称或呈现JSON响应，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/error"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">handle</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"status"</span>, request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>));</span><br><span class="line">        map.put(<span class="string">"reason"</span>, request.getAttribute(<span class="string">"javax.servlet.error.message"</span>));</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Session-Resolver"><a href="#Session-Resolver" class="headerlink" title="Session Resolver"></a>Session Resolver</h5><blockquote>
<p>sessionLocalerResolver允许您从可能与用户请求关联的会话中检索区域设置和时区。与CookielocalResolver不同，此策略将本地选择的区域设置存储在Servlet容器的HttpSession中。因此，这些设置是每个会话的临时设置，因此在每个会话终止时丢失。</p>
<p>请注意，与外部会话管理机制（如Spring会话项目）没有直接关系。此sessionLocalerResolver根据当前HttpServletRequest计算并修改相应的HttpSession属性。</p>
</blockquote>
<h4 id="1-1-11-Multipart-Resolver"><a href="#1-1-11-Multipart-Resolver" class="headerlink" title="1.1.11. Multipart Resolver"></a>1.1.11. Multipart Resolver</h4><blockquote>
<p>来自org.springframework.web.multipart包的MultipartResolver是一种分析包括文件上传在内的多部分请求的策略。其中有一种实现基于Commons FileUpload，另一种实现基于Servlet 3.0多部分请求解析。</p>
<ol>
<li>要启用多部分处理，需要在DispatcherServlet Spring配置中使用MultipartResolver的一个名称声明MultipartResolver bean最佳。DispatcherServlet将检测到它并将其应用于传入的请求。</li>
<li>当接收到内容类型为multipart/form数据的POST时，<strong>解析器解析内容并将当前HttpServletRequest包装为multiparttpservletrequest，以提供对已解析部分的访问</strong>，并将其作为请求参数公开。</li>
</ol>
</blockquote>
<h5 id="Apache-Commons-FileUpload"><a href="#Apache-Commons-FileUpload" class="headerlink" title="Apache Commons FileUpload"></a>Apache Commons <code>FileUpload</code></h5><p>To use Apache Commons <code>FileUpload</code>, you can configure a bean of type <code>CommonsMultipartResolver</code> with a name of <code>multipartResolver</code>. You also need to have <code>commons-fileupload</code> as a dependency on your classpath.</p>
<h5 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a>Servlet 3.0</h5><p>Servlet 3.0 multipart parsing needs to be enabled through Servlet container configuration. To do so:</p>
<ul>
<li>In Java, set a <code>MultipartConfigElement</code> on the Servlet registration.</li>
<li>In <code>web.xml</code>, add a <code>&quot;&quot;</code> section to the servlet declaration.</li>
</ul>
<p>The following example shows how to set a <code>MultipartConfigElement</code> on the Servlet registration:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(ServletRegistration.Dynamic registration)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold</span></span><br><span class="line">        registration.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(<span class="string">"/tmp"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Once the Servlet 3.0 configuration is in place, you can add a bean of type <code>StandardServletMultipartResolver</code> with a name of <code>multipartResolver</code>.</p>
<h3 id="1-2-Filters"><a href="#1-2-Filters" class="headerlink" title="1.2. Filters"></a>1.2. Filters</h3><h3 id="1-3-Annotated-Controllers-Controller-RestController"><a href="#1-3-Annotated-Controllers-Controller-RestController" class="headerlink" title="1.3. Annotated Controllers: @Controller @RestController"></a>1.3. Annotated Controllers: @Controller @RestController</h3><h4 id="1-3-1-Declaration"><a href="#1-3-1-Declaration" class="headerlink" title="1.3.1. Declaration"></a>1.3.1. Declaration</h4><blockquote>
<p>Spring MVC提供了一个基于注释的编程模型，其中@Controller和@RestController组件使用注释来表示请求映射、请求输入、异常处理等。带注释的控制器具有灵活的方法识别标志，无需扩展基类或实现特定接口。</p>
<p>分派器（<code>DispatcherServlet</code>）会自动扫描所有注解了<code>@Controller</code>的类，检测其中通过<code>@RequestMapping</code>注解配置的方法。</p>
</blockquote>
<h6 id="1、自定义控制器的bean组件："><a href="#1、自定义控制器的bean组件：" class="headerlink" title="1、自定义控制器的bean组件："></a>1、自定义控制器的bean组件：</h6><blockquote>
<p>遵循WebApplicationContext的组件标准，而且spring支持自动检测在类路径下的@Component类与自动注册bean组件。</p>
</blockquote>
<ul>
<li>配置类：为了能够自动检测到控制器的bean组件，需要使用@ComponentScan：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"org.example.web"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>xml文件配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example.web"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="2、-RestController"><a href="#2、-RestController" class="headerlink" title="2、@RestController"></a>2、@RestController</h6><blockquote>
<p>是@Controller和@Responsebody的结合体，一方面表明这是一个控制器，另一方面其方法继承了@Responsebody，因此该类中方法直接写入响应体，而不是通过视图解析和HTML模板呈现</p>
</blockquote>
<h6 id="3、面向切面（AOP）代理"><a href="#3、面向切面（AOP）代理" class="headerlink" title="3、面向切面（AOP）代理"></a>3、面向切面（AOP）代理</h6><p>@Controller控制器默认选择AOP代理，可使用@Transactional管理事务，但是在控制器需要实现特定接口【而该接口又不支持Spring Context的回调（比如<code>InitializingBean</code>, <code>*Aware</code>等接口）】的时候，则需要自行配置代理。</p>
<p>For example with  </p>
<p><code>&lt;tx:annotation-driven/&gt;,</code>change to <code>&lt;tx:annotation-driven proxy-target-class=&quot;true&quot;/&gt;</code></p>
<h4 id="1-3-2-Request-Mapping"><a href="#1-3-2-Request-Mapping" class="headerlink" title="1.3.2. Request Mapping"></a>1.3.2. Request Mapping</h4><blockquote>
<p><code>@RequestMapping</code>注解默认会映射所有的HTTP请求方法。如果仅想接收某种请求方法，请在注解中指定之<code>@RequestMapping(method=GET)</code>以缩小范围。</p>
<p>把控制器中的一系列处理方法当成是一系列独立的服务节点，每个从类级别和方法级别的<code>@RequestMapping</code>注解中获取到足够请求路径映射信息。【RequestMappingHandlerMapping】</p>
</blockquote>
<p>There are also HTTP method specific shortcut variants of <code>@RequestMapping</code>:</p>
<ul>
<li><code>@GetMapping</code>  该方法接受一个模型model并以字符串Sring形式返回一个视图名</li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>在类级别使用@RequestMapping来表示共享映射, 再在控制器方法上使用可区别的映射方式。即classes level +method level的映射组成了一个<strong>特定的http请求路径</strong>。</p>
<blockquote>
<ul>
<li>一般来说，类级别的注解负责将一个特定（或符合某种模式）的请求路径映射到一个控制器上，同时通过方法级别的注解来细化映射，即根据特定的HTTP请求方法（“GET”“POST”方法等）、HTTP请求中是否携带特定参数等条件，将请求映射到匹配的方法上。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/persons"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(@RequestBody Person person)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URI-patterns：URI模板"><a href="#URI-patterns：URI模板" class="headerlink" title="URI patterns：URI模板"></a>URI patterns：URI模板</h5><blockquote>
<p>URI模板是一个类似于URI的字符串，只不过其中包含了一个或多个的变量名。当你使用实际的值去填充这些变量名的时候，模板就退化成了一个URI。即URI进行了参数化。</p>
</blockquote>
<p>您可以使用glob模式和通配符映射请求：</p>
<ul>
<li>?  匹配一个字符</li>
<li>*匹配路径段中的零个或多个字符</li>
<li>**匹配零个或多个路径段</li>
</ul>
<h5 id="1、-PathVariable：可以声明URI变量并使用-PathVariable访问它们的值："><a href="#1、-PathVariable：可以声明URI变量并使用-PathVariable访问它们的值：" class="headerlink" title="1、@PathVariable：可以声明URI变量并使用@PathVariable访问它们的值："></a><strong>1、@PathVariable</strong>：可以声明URI变量并使用<strong>@PathVariable</strong>访问它们的值：</h5><blockquote>
<ol>
<li><p>在Spring MVC中你可以在方法参数上使用<code>@PathVariable</code>注解，将其与URI模板中的参数绑定起来：</p>
</li>
<li><p>URI变量将自动转换为适当的类型，或者引发“TypeMismatchException”。默认情况下支持简单类型 - int、long、Date，您可以注册对任何其他数据类型的支持。请参见类型转换和绑定方法。</p>
</li>
</ol>
<ol start="3">
<li><p>Spring MVC可通过显式命名@PathVariables中变量名来找到URI模板中相对应的变量。 </p>
<p>URI变量可以显式地命名为 - ，例如@PathVariable（“customId”）</p>
<ul>
<li><p>如果URI模板中的变量名与方法的参数名是相同的，则你可以不必再指定一次。</p>
</li>
<li><p>一个方法可以拥有任意数量的<code>@PathVariable</code>注解</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnerController</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果URI模板中的变量名与方法的参数名是相同的，则可以不必再指定一次。</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/pets/&#123;petId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">findPet</span><span class="params">(@PathVariable Long ownerId, @PathVariable Long petId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/owners/&#123;ownerId&#125;&#125;"</span>, method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findOwner</span><span class="params">(@PathVariable(<span class="string">"ownerId"</span>)</span> String theOwner, Model model) </span>&#123;</span><br><span class="line">    <span class="comment">// 具体的方法代码…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、可以使用正则表达式声明uri变量："><a href="#2、可以使用正则表达式声明uri变量：" class="headerlink" title="2、可以使用正则表达式声明uri变量："></a>2、可以使用正则表达式声明uri变量：</h5><blockquote>
<p>语法：<code>{varName:regex}</code>  第一部分定义了变量名，第二部分就是你所要应用的正则表达式</p>
<p>Spring MVC使用PathMatcher契约和来自Spring core的AntPathMatcher实现进行URI路径匹配。</p>
<p>下面的方法提取名称、版本和文件扩展名：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(@PathVariable String version, @PathVariable String ext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、Pattern-comparison：模式比较-路径匹配"><a href="#3、Pattern-comparison：模式比较-路径匹配" class="headerlink" title="3、Pattern comparison：模式比较/路径匹配"></a>3、Pattern comparison：模式比较/路径匹配</h5><p>最佳匹配：This done via <code>AntPathMatcher.getPatternComparator(String path)</code> which looks for patterns that more specific.</p>
<p><strong>匹配顺序</strong>：</p>
<ul>
<li><p>即越具体 匹配分数越高，URI模板变量的数目和通配符数量的总和最少的那个路径模板更准确。</p>
</li>
<li><p>匹配得分：URI变量&gt;单个通配符&gt;多个通配符&gt;前缀模式&gt;/**</p>
<p>默认的映射模式 /** 不包括在评分中，并且总是最后排序。此外，前缀模式（如 /public/** ）被认为比其他任何不包括双通配符的模式更不具体。</p>
</li>
</ul>
<blockquote>
<p>更多的细节请参考这两个类：<code>AntPatternComparator</code>和<code>AntPathMatcher</code>。值得一提的是，PathMatcher类是可以配置的。</p>
</blockquote>
<h5 id="4-Suffix-Match-后缀匹配"><a href="#4-Suffix-Match-后缀匹配" class="headerlink" title="4. Suffix Match/后缀匹配"></a>4. Suffix Match/后缀匹配</h5><blockquote>
<ol>
<li><p>默认情况下，Spring MVC采用<code>&quot;.*&quot;</code>的后缀模式匹配来进行路径匹配，即所有在/person路径下的的控制器会被隐式映射到/person.*。</p>
</li>
<li><p>可利用不同的文件扩展名解析对应的请求内容类型（即，代替接收头）  ，以响应请求。</p>
<p>例如/person.pdf、/person.xml和其他。</p>
<p>当使用URI变量、路径参数和URI编码覆盖时，文件扩展名可能会导致歧义。目前首选是使用接收头，而当浏览器用来发送难以一致解释的接受头时，则可使用文件扩展名来区分解析。</p>
</li>
</ol>
</blockquote>
<p>要完全<strong>禁用文件扩展名</strong>的使用，必须同时设置以下两项：</p>
<ul>
<li><code>useSuffixPatternMatching(false)</code>, see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config-path-matching" target="_blank" rel="noopener">PathMatchConfigurer</a></li>
<li><code>favorPathExtension(false)</code>, see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config-content-negotiation" target="_blank" rel="noopener">ContentNegotiationConfigurer</a></li>
</ul>
<blockquote>
<p>建议使用基于查询参数的策略，以避免文件扩展名带来的大多数问题。或者，如果必须使用文件扩展名，请考虑通过ContentNegotiationConfigurer的mediaTypes属性将它们限制为显式注册的扩展名列表。</p>
</blockquote>
<blockquote>
<p>从5.2.4开始，在<strong><em>RequestMappingHandlerMapping中的请求映射和在ContentNegotiationManagerFactoryBean中的内容协商的路径扩展相关选项</em></strong>将被弃用。更多计划见Spring框架问题#24179及相关问题。</p>
</blockquote>
<h5 id="5-Suffix-Match-and-RFD-后缀模式匹配与RFD"><a href="#5-Suffix-Match-and-RFD-后缀模式匹配与RFD" class="headerlink" title="5.Suffix Match and RFD/后缀模式匹配与RFD"></a>5.Suffix Match and RFD/后缀模式匹配与RFD</h5><blockquote>
<p>反射文件下载（reflected file download，RFD）攻击与XSS类似，它依赖于响应中反射的请求输入（例如，查询参数和URI变量）。然而，RFD攻击不是将JavaScript插入HTML，而是依赖于浏览器页面切换来执行下载，并在以后双击时将响应视为可执行脚本。</p>
<p>在Spring MVC中，@ResponseBody和ResponseEntity方法面临风险，因为它们会根据客户的请求——包括URL的路径后缀，来渲染不同的内容类型。禁用后缀模式匹配和使用路径扩展进行内容协商可以降低风险，但不足以防止RFD攻击。</p>
<p>为了防止RFD攻击，在呈现响应体之前，Spring MVC添加了一个<strong>Content-Disposition:inline;filename=f.txt</strong>  头，以指定固定的下载文件的文件名。这仅在URL路径中包含了一个文件符合以下特征的拓展名时适用：该扩展名既不在信任列表（白名单）中，也没有被显式地被注册于内容协商时使用。并且这种做法还可以有一些副作用，比如，当URL是通过浏览器手动输入的时候。</p>
<blockquote>
<p>默认情况下，许多公共路径扩展都是白名单。具有自定义HttpMessageConverter实现的应用程序可以显式注册用于内容协商的文件扩展名，以避免为这些扩展名添加内容处置头。请参见内容类型。<br>有关RFD的其他建议，见CVE-2015-5211。</p>
</blockquote>
</blockquote>
<h5 id="6-Consumable-Media-Types"><a href="#6-Consumable-Media-Types" class="headerlink" title="6.Consumable Media Types"></a>6.Consumable Media Types</h5><p>可以根据请求的内容类型缩小请求映射范围，如下例所示：</p>
<p>Using a <code>consumes</code> attribute to narrow the mapping by the content type.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(path = <span class="string">"/pets"</span>, consumes = <span class="string">"application/json"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPet</span><span class="params">(@RequestBody Pet pet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>consumes属性还支持否定表达式 - ，例如！text/plain是指除text/plain以外的任何内容类型。</li>
<li>可以在类级别声明一个consumes属性。但与大多数其他请求映射属性不同，当在类级别声明consumes属性时，方法级别会进行属性重写，而不是扩展类级别声明。</li>
<li>MediaType还为常用的媒体类型（如APPLICATION_JSON_VALUE和APPLICATION_XML_VALUE）提供常量。</li>
</ul>
<h5 id="7-Producible-Media-Types"><a href="#7-Producible-Media-Types" class="headerlink" title="7.Producible Media Types"></a>7.Producible Media Types</h5><blockquote>
<p>与Consumable Media Types相似</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets/&#123;petId&#125;"</span>, produces = <span class="string">"application/json"</span>) </span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-Parameters-headers"><a href="#8-Parameters-headers" class="headerlink" title="8.Parameters, headers"></a>8.Parameters, headers</h5><p>可以基于请求参数条件缩小请求映射范围。可以检查是否存在请求参数（myParam），是否缺少一个特定值，及规定特定条件（myParam=myValue）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets/&#123;petId&#125;"</span>, params = <span class="string">"myParam=myValue"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以对请求头条件使用相同的条件，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets"</span>, headers = <span class="string">"myHeader=myValue"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您可以将内容类型和Accept与headers条件匹配，但最好使用consumers和products。</p>
</blockquote>
<h5 id="9-HTTP-HEAD-OPTIONS-HTTP头，选项"><a href="#9-HTTP-HEAD-OPTIONS-HTTP头，选项" class="headerlink" title="9.HTTP HEAD, OPTIONS / HTTP头，选项"></a>9.HTTP HEAD, OPTIONS / HTTP头，选项</h5><blockquote>
<p>@GetMapping（和@RequestMapping（method=HttpMethod.GET））隐式映射到并支持HTTP HEAD。一个HTTP HEAD请求被当作HTTP GET来处理，只是不写正文，而是计算字节数并设置内容长度头。</p>
<p>默认情况下，通过将Allow response头设置为所有@RequestMapping方法中列出的能够进行URL匹配的HTTP方法列表来处理HTTP选项。</p>
<p>对于没有HTTP方法声明的@RequestMapping，Allow头被设置为GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS。控制器方法应始终声明受支持的HTTP方法（例如，使用HTTP方法特定的变量：@GetMapping、@PostMapping和其他变量）。</p>
</blockquote>
<ol start="10">
<li><h5 id="Custom-Annotations-自定义注解"><a href="#Custom-Annotations-自定义注解" class="headerlink" title="Custom Annotations/自定义注解"></a>Custom Annotations/自定义注解</h5></li>
</ol>
<p>Spring MVC 支持使用组合注解@GetMapping、@PostMapping、@PutMapping、@DeleteMapping和@PatchMapping来执行更具体的用途。</p>
<blockquote>
<p>这些注释本身就是用@RequestMapping进行元注释的注释，用于重新声明@RequestMapping属性的一个子集（或全部），具有更窄、更具体的用途。</p>
<p>Spring MVC还支持具有 <strong>自定义请求匹配逻辑的自定义请求映射属性</strong>，其需要子类化RequestMappingHandlerMapping并重写getCustomMethodCondition方法，可以在该方法中检查自定义属性并返回自己的RequestCondition。</p>
</blockquote>
<h5 id="11-Explicit-Registrations-注册处理器方法"><a href="#11-Explicit-Registrations-注册处理器方法" class="headerlink" title="11.Explicit Registrations/注册处理器方法"></a>11.Explicit Registrations/注册处理器方法</h5><p>您可以以编程方式注册处理器方法，这些方法可用于动态注册或高级情况，例如不同URL下同一处理程序的不同实例。以下示例注册处理器方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//为控制器注入目标处理程序和处理程序映射。</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHandlerMapping</span><span class="params">(RequestMappingHandlerMapping mapping, UserHandler handler)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line"><span class="comment">//准备请求映射元数据。</span></span><br><span class="line">        RequestMappingInfo info = RequestMappingInfo</span><br><span class="line">                .paths(<span class="string">"/user/&#123;id&#125;"</span>).methods(RequestMethod.GET).build(); </span><br><span class="line"><span class="comment">//获取处理器方法。</span></span><br><span class="line">        Method method = UserHandler.class.getMethod("getUser", Long.class); </span><br><span class="line"><span class="comment">//添加注册。</span></span><br><span class="line">        mapping.registerMapping(info, handler, method); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-3-Handler-Methods-处理器方法"><a href="#1-3-3-Handler-Methods-处理器方法" class="headerlink" title="1.3.3. Handler Methods/处理器方法"></a>1.3.3. Handler Methods/处理器方法</h4><h5 id="1-控制器方法参数描述"><a href="#1-控制器方法参数描述" class="headerlink" title="1.控制器方法参数描述"></a>1.控制器方法参数描述</h5><p>下表描述支持的控制器方法参数。及任何参数都不支持响应类型。</p>
<table>
<thead>
<tr>
<th align="left">Controller method argument</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>WebRequest</code>, <code>NativeWebRequest</code></td>
<td align="left">Generic access to request parameters and request and session attributes, without direct use of the Servlet API.</td>
</tr>
<tr>
<td align="left"><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td>
<td align="left">Choose any specific request or response type — for example, <code>ServletRequest</code>, <code>HttpServletRequest</code>, or Spring’s <code>MultipartRequest</code>, <code>MultipartHttpServletRequest</code>.</td>
</tr>
<tr>
<td align="left"><code>javax.servlet.http.HttpSession</code></td>
<td align="left">Enforces the presence of a session. As a consequence, such an argument is never <code>null</code>. Note that session access is not thread-safe. Consider setting the <code>RequestMappingHandlerAdapter</code> instance’s <code>synchronizeOnSession</code> flag to <code>true</code> if multiple requests are allowed to concurrently access a session.</td>
</tr>
<tr>
<td align="left"><code>javax.servlet.http.PushBuilder</code></td>
<td align="left">Servlet 4.0 push builder API for programmatic HTTP/2 resource pushes. Note that, per the Servlet specification, the injected <code>PushBuilder</code> instance can be null if the client does not support that HTTP/2 feature.</td>
</tr>
<tr>
<td align="left"><code>java.security.Principal</code></td>
<td align="left">Currently authenticated user — possibly a specific <code>Principal</code> implementation class if known.</td>
</tr>
<tr>
<td align="left"><code>HttpMethod</code></td>
<td align="left">The HTTP method of the request.</td>
</tr>
<tr>
<td align="left"><code>java.util.Locale</code></td>
<td align="left">The current request locale, determined by the most specific <code>LocaleResolver</code> available (in effect, the configured <code>LocaleResolver</code> or <code>LocaleContextResolver</code>).</td>
</tr>
<tr>
<td align="left"><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td>
<td align="left">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</td>
</tr>
<tr>
<td align="left"><code>java.io.InputStream</code>, <code>java.io.Reader</code></td>
<td align="left">For access to the raw request body as exposed by the Servlet API.</td>
</tr>
<tr>
<td align="left"><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td>
<td align="left">For access to the raw response body as exposed by the Servlet API.</td>
</tr>
<tr>
<td align="left"><code>@PathVariable</code></td>
<td align="left">For access to URI template variables. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-uri-templates" target="_blank" rel="noopener">URI patterns</a>.</td>
</tr>
<tr>
<td align="left"><code>@MatrixVariable</code></td>
<td align="left">For access to name-value pairs in URI path segments. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-matrix-variables" target="_blank" rel="noopener">Matrix Variables</a>.</td>
</tr>
<tr>
<td align="left"><code>@RequestParam</code></td>
<td align="left">For access to the Servlet request parameters, including multipart files. Parameter values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestparam" target="_blank" rel="noopener"><code>@RequestParam</code></a> as well as <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-multipart-forms" target="_blank" rel="noopener">Multipart</a>.Note that use of <code>@RequestParam</code> is optional for simple parameter values. See “Any other argument”, at the end of this table.</td>
</tr>
<tr>
<td align="left"><code>@RequestHeader</code></td>
<td align="left">For access to request headers. Header values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestheader" target="_blank" rel="noopener"><code>@RequestHeader</code></a>.</td>
</tr>
<tr>
<td align="left"><code>@CookieValue</code></td>
<td align="left">For access to cookies. Cookies values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-cookievalue" target="_blank" rel="noopener"><code>@CookieValue</code></a>.</td>
</tr>
<tr>
<td align="left"><code>@RequestBody</code></td>
<td align="left">For access to the HTTP request body. Body content is converted to the declared method argument type by using <code>HttpMessageConverter</code> implementations. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestbody" target="_blank" rel="noopener"><code>@RequestBody</code></a>.</td>
</tr>
<tr>
<td align="left"><code>HttpEntity</code></td>
<td align="left">For access to request headers and body. The body is converted with an <code>HttpMessageConverter</code>. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-httpentity" target="_blank" rel="noopener">HttpEntity</a>.</td>
</tr>
<tr>
<td align="left"><code>@RequestPart</code></td>
<td align="left">For access to a part in a <code>multipart/form-data</code> request, converting the part’s body with an <code>HttpMessageConverter</code>. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-multipart-forms" target="_blank" rel="noopener">Multipart</a>.</td>
</tr>
<tr>
<td align="left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td>
<td align="left">For access to the model that is used in HTML controllers and exposed to templates as part of view rendering.</td>
</tr>
<tr>
<td align="left"><code>RedirectAttributes</code></td>
<td align="left">Specify attributes to use in case of a redirect (that is, to be appended to the query string) and flash attributes to be stored temporarily until the request after redirect. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-redirecting-passing-data" target="_blank" rel="noopener">Redirect Attributes</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-flash-attributes" target="_blank" rel="noopener">Flash Attributes</a>.</td>
</tr>
<tr>
<td align="left"><code>@ModelAttribute</code></td>
<td align="left">For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-modelattrib-method-args" target="_blank" rel="noopener"><code>@ModelAttribute</code></a> as well as <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-modelattrib-methods" target="_blank" rel="noopener">Model</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-initbinder" target="_blank" rel="noopener"><code>DataBinder</code></a>.Note that use of <code>@ModelAttribute</code> is optional (for example, to set its attributes). See “Any other argument” at the end of this table.</td>
</tr>
<tr>
<td align="left"><code>Errors</code>, <code>BindingResult</code></td>
<td align="left">For access to errors from validation and data binding for a command object (that is, a <code>@ModelAttribute</code> argument) or errors from the validation of a <code>@RequestBody</code> or <code>@RequestPart</code> arguments. You must declare an <code>Errors</code>, or <code>BindingResult</code> argument immediately after the validated method argument.</td>
</tr>
<tr>
<td align="left"><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></td>
<td align="left">For marking form processing complete, which triggers cleanup of session attributes declared through a class-level <code>@SessionAttributes</code> annotation. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-sessionattributes" target="_blank" rel="noopener"><code>@SessionAttributes</code></a> for more details.</td>
</tr>
<tr>
<td align="left"><code>UriComponentsBuilder</code></td>
<td align="left">For preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-uri-building" target="_blank" rel="noopener">URI Links</a>.</td>
</tr>
<tr>
<td align="left"><code>@SessionAttribute</code></td>
<td align="left">For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level <code>@SessionAttributes</code> declaration. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-sessionattribute" target="_blank" rel="noopener"><code>@SessionAttribute</code></a> for more details.</td>
</tr>
<tr>
<td align="left"><code>@RequestAttribute</code></td>
<td align="left">For access to request attributes. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestattrib" target="_blank" rel="noopener"><code>@RequestAttribute</code></a> for more details.</td>
</tr>
<tr>
<td align="left">Any other argument</td>
<td align="left">If a method argument is not matched to any of the earlier values in this table and it is a simple type (as determined by <a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-" target="_blank" rel="noopener">BeanUtils#isSimpleProperty</a>, it is a resolved as a <code>@RequestParam</code>. Otherwise, it is resolved as a <code>@ModelAttribute</code>.</td>
</tr>
</tbody></table>
<h5 id="2-Return-Values"><a href="#2-Return-Values" class="headerlink" title="2.Return Values"></a>2.Return Values</h5><p>下表描述支持的控制器方法返回值。所有返回值都支持响应类型。</p>
<table>
<thead>
<tr>
<th align="left">Controller method return value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@ResponseBody</code></td>
<td align="left">The return value is converted through <code>HttpMessageConverter</code> implementations and written to the response. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-responsebody" target="_blank" rel="noopener"><code>@ResponseBody</code></a>.</td>
</tr>
<tr>
<td align="left"><code>HttpEntity</code>, <code>ResponseEntity</code></td>
<td align="left">The return value that specifies the full response (including HTTP headers and body) is to be converted through <code>HttpMessageConverter</code> implementations and written to the response. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-responseentity" target="_blank" rel="noopener">ResponseEntity</a>.</td>
</tr>
<tr>
<td align="left"><code>HttpHeaders</code></td>
<td align="left">For returning a response with headers and no body.</td>
</tr>
<tr>
<td align="left"><code>String</code></td>
<td align="left">A view name to be resolved with <code>ViewResolver</code> implementations and used together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-registration" target="_blank" rel="noopener">Explicit Registrations</a>).</td>
</tr>
<tr>
<td align="left"><code>View</code></td>
<td align="left">A <code>View</code> instance to use for rendering together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-registration" target="_blank" rel="noopener">Explicit Registrations</a>).</td>
</tr>
<tr>
<td align="left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td>
<td align="left">Attributes to be added to the implicit model, with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.</td>
</tr>
<tr>
<td align="left"><code>@ModelAttribute</code></td>
<td align="left">An attribute to be added to the model, with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.Note that <code>@ModelAttribute</code> is optional. See “Any other return value” at the end of this table.</td>
</tr>
<tr>
<td align="left"><code>ModelAndView</code> object</td>
<td align="left">The view and model attributes to use and, optionally, a response status.</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left">A method with a <code>void</code> return type (or <code>null</code> return value) is considered to have fully handled the response if it also has a <code>ServletResponse</code>, an <code>OutputStream</code> argument, or an <code>@ResponseStatus</code> annotation. The same is also true if the controller has made a positive <code>ETag</code> or <code>lastModified</code> timestamp check (see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-caching-etag-lastmodified" target="_blank" rel="noopener">Controllers</a> for details).If none of the above is true, a <code>void</code> return type can also indicate “no response body” for REST controllers or a default view name selection for HTML controllers.</td>
</tr>
<tr>
<td align="left"><code>DeferredResult</code></td>
<td align="left">Produce any of the preceding return values asynchronously from any thread — for example, as a result of some event or callback. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-deferredresult" target="_blank" rel="noopener"><code>DeferredResult</code></a>.</td>
</tr>
<tr>
<td align="left"><code>Callable</code></td>
<td align="left">Produce any of the above return values asynchronously in a Spring MVC-managed thread. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-callable" target="_blank" rel="noopener"><code>Callable</code></a>.</td>
</tr>
<tr>
<td align="left"><code>ListenableFuture</code>, <code>java.util.concurrent.CompletionStage</code>, <code>java.util.concurrent.CompletableFuture</code></td>
<td align="left">Alternative to <code>DeferredResult</code>, as a convenience (for example, when an underlying service returns one of those).</td>
</tr>
<tr>
<td align="left"><code>ResponseBodyEmitter</code>, <code>SseEmitter</code></td>
<td align="left">Emit a stream of objects asynchronously to be written to the response with <code>HttpMessageConverter</code> implementations. Also supported as the body of a <code>ResponseEntity</code>. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming" target="_blank" rel="noopener">HTTP Streaming</a>.</td>
</tr>
<tr>
<td align="left"><code>StreamingResponseBody</code></td>
<td align="left">Write to the response <code>OutputStream</code> asynchronously. Also supported as the body of a <code>ResponseEntity</code>. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming" target="_blank" rel="noopener">HTTP Streaming</a>.</td>
</tr>
<tr>
<td align="left">Reactive types — Reactor, RxJava, or others through <code>ReactiveAdapterRegistry</code></td>
<td align="left">Alternative to <code>DeferredResult</code> with multi-value streams (for example, <code>Flux</code>, <code>Observable</code>) collected to a <code>List</code>.For streaming scenarios (for example, <code>text/event-stream</code>, <code>application/json+stream</code>), <code>SseEmitter</code> and <code>ResponseBodyEmitter</code> are used instead, where <code>ServletOutputStream</code> blocking I/O is performed on a Spring MVC-managed thread and back pressure is applied against the completion of each write.See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-reactive-types" target="_blank" rel="noopener">Reactive Types</a>.</td>
</tr>
<tr>
<td align="left">Any other return value</td>
<td align="left">Any return value that does not match any of the earlier values in this table and that is a <code>String</code> or <code>void</code> is treated as a view name (default view name selection through <code>RequestToViewNameTranslator</code> applies), provided it is not a simple type, as determined by <a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-" target="_blank" rel="noopener">BeanUtils#isSimpleProperty</a>. Values that are simple types remain unresolved.</td>
</tr>
</tbody></table>
<p>3.类型转换</p>
<blockquote>
<p>如果参数声明为字符串以外的其他值，则<strong>表示基于字符串的请求输入的某些带注释的控制器方法参数</strong>（例如@RequestParam、@RequestHeader、@PathVariable、@MatrixVariable和@CookieValue）可能需要类型转换。</p>
</blockquote>
<p>在这种情况下，根据配置的转换器自动应用类型转换。默认情况下，支持简单类型（int、long、Date和其他类型）。可以通过WebDataBinder（请参阅DataBinder）或通过向FormattingConversionService注册格式化程序来自定义类型转换。请参见Spring字段格式。</p>
<h5 id="3-MatrixVariable-矩阵变量"><a href="#3-MatrixVariable-矩阵变量" class="headerlink" title="3.@MatrixVariable/矩阵变量"></a>3.@MatrixVariable/矩阵变量</h5><blockquote>
<p>矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔（例如，/cars；color=red，green；year=2012）。也可以通过重复的变量名指定多个值（例如，color=red；color=green；color=blue）。</p>
</blockquote>
<p>如果URL预期包含矩阵变量，则控制器方法的请求映射必须使用一个URI变量来屏蔽该变量内容，并确保可以独立于矩阵变量的顺序和存在,进行成功匹配。以下示例使用矩阵变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /pets/42;q=11;r=22</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/pets/&#123;petId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String petId, @MatrixVariable <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// petId == 42</span></span><br><span class="line">    <span class="comment">// q == 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到所有路径段都可能包含矩阵变量，您有时可能需要消除矩阵变量位于对应路径变量中的歧义。下面的示例演示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /owners/42;q=11/pets/21;q=22</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @MatrixVariable(name=<span class="string">"q"</span>, pathVar=<span class="string">"ownerId"</span>)</span> <span class="keyword">int</span> q1,</span></span><br><span class="line"><span class="function">        @<span class="title">MatrixVariable</span><span class="params">(name=<span class="string">"q"</span>, pathVar=<span class="string">"petId"</span>)</span> <span class="keyword">int</span> q2) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// q1 == 11</span></span><br><span class="line">    <span class="comment">// q2 == 22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将矩阵变量定义为可选变量，并指定默认值，如下例所示：</p>
<p>要获取所有矩阵变量，可以使用多值映射，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,</span></span></span><br><span class="line"><span class="function"><span class="params">        @MatrixVariable(pathVar=<span class="string">"petId"</span>)</span> MultiValueMap&lt;String, String&gt; petMatrixVars) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]</span></span><br><span class="line">    <span class="comment">// petMatrixVars: ["q" : 22, "s" : 23]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启用矩阵变量：</p>
<ul>
<li>在MVC Java配置中，需要在路径匹配中将UrlPathHelper设置为removeSemicolonContent=false。</li>
<li>在MVC XML名称空间中，可以设置&lt;MVC:annotation-driven enable matrix variables=“true”/&gt;。</li>
</ul>
<h5 id="4-RequestParam"><a href="#4-RequestParam" class="headerlink" title="4.@RequestParam"></a>4.<code>@RequestParam</code></h5><p>可以使用@RequestParam注释将Servlet请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/pets"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditPetForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="comment">//	Using @RequestParam to bind petId.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setupForm</span><span class="params">(@RequestParam(<span class="string">"petId"</span>)</span> <span class="keyword">int</span> petId, Model model) </span>&#123; </span><br><span class="line">        Pet pet = <span class="keyword">this</span>.clinic.loadPet(petId);</span><br><span class="line">        model.addAttribute(<span class="string">"pet"</span>, pet);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"petForm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认情况下，使用@RequestParam的方法参数是必需的，但是您可以通过将@RequestParam的required属性设置为false 或使用java.util.optional包装声明参数 来指定方法参数是可选的。</p>
<ol>
<li>如果目标方法参数类型不是字符串，则自动应用类型转换。请参见类型转换。</li>
<li>将参数类型声明为数组或列表 允许解析同一参数名的多个参数值。</li>
<li>当@RequestParam注释声明为Map&lt;String，String&gt;或MultiValueMap&lt;String，String&gt;时，如果没有在注释中指定参数名，则映射将填充每个给定参数名的请求参数值。</li>
</ol>
</blockquote>
<h5 id="5-RequestHeader"><a href="#5-RequestHeader" class="headerlink" title="5.@RequestHeader"></a>5.<code>@RequestHeader</code></h5><h5 id="6-CookieValue"><a href="#6-CookieValue" class="headerlink" title="6.@CookieValue"></a>6.<code>@CookieValue</code></h5><h5 id="7-ModelAttribute"><a href="#7-ModelAttribute" class="headerlink" title="7.@ModelAttribute"></a>7.<code>@ModelAttribute</code></h5><p>可以对方法参数使用@ModeAttribute注释来访问模型中的属性，或者在不存在的情况下将其实例化。</p>
<blockquote>
<p>model属性还覆盖有来自HTTP Servlet请求参数的值，这些参数的名称会与字段名匹配，进行<strong>数据绑定</strong>，这样就<strong>不必处理解析和转换单个查询参数和表单字段</strong>。下面的示例演示了如何执行此操作：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit"</span>)</span><br><span class="line"><span class="comment">//Bind an instance of Pet.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processSubmit</span><span class="params">(@ModelAttribute Pet pet)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>一般情况是使用Model类型接收数据，但也可依赖转换器&lt;String，T&gt;和URI路径变量匹配机制来接收。</p>
<blockquote>
<p>在下面的示例中，模型属性名称account与URI路径变量account匹配，通过默认注册的转换器&lt;String，account&gt;将字符串类型的账户号转换成account类型，完成加载：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/accounts/&#123;account&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(@ModelAttribute(<span class="string">"account"</span>)</span> Account account) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取Model实例后，进行数据绑定。WebDataBinder类 将Servlet请求参数名（查询参数和表单字段）与目标对象上的字段名匹配。必要时，在进行类型转换后填充匹配字段。</p>
<blockquote>
<p>有关数据绑定（和验证）的更多信息，请参阅 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation" target="_blank" rel="noopener">Validation</a>。有关自定义数据绑定的详细信息，请参阅<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-initbinder" target="_blank" rel="noopener"><code>DataBinder</code></a>。</p>
</blockquote>
<p>数据绑定可能导致错误。默认情况下，会引发BindException。但是，要检查controller方法中是否存在此类错误，可以在@ModelAttribute旁边立即添加<strong>BindingResult参数</strong>，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit"</span>)</span><br><span class="line"><span class="comment">//	Adding a BindingResult next to the @ModelAttribute.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processSubmit</span><span class="params">(@ModelAttribute(<span class="string">"pet"</span>)</span> Pet pet, BindingResult result) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"petForm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，您可能希望访问不带数据绑定的模型属性。对于这种情况，可以<strong>将模型注入控制器并直接访问它</strong>，或者<strong>设置@modeltattribute（binding=false）</strong>，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AccountForm <span class="title">setUpForm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountForm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">findAccount</span><span class="params">(@PathVariable String accountId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accountRepository.findOne(accountId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"update"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(@Valid AccountForm form, BindingResult result,</span></span></span><br><span class="line"><span class="function"><span class="params">        @ModelAttribute(binding=<span class="keyword">false</span>)</span> Account account) </span>&#123; <span class="comment">//Setting @ModelAttribute(binding=false).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过添加 javax.validation.Valid 注释或Spring的@Validated注释（ <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation-beanvalidation" target="_blank" rel="noopener">Bean Validation</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation" target="_blank" rel="noopener">Spring validation</a>），可以在数据绑定后进行自动验证。下面的示例演示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit"</span>)</span><br><span class="line"><span class="comment">//Validate the Pet instance.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processSubmit</span><span class="params">(@Valid @ModelAttribute(<span class="string">"pet"</span>)</span> Pet pet, BindingResult result) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"petForm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="8-SessionAttributes"><a href="#8-SessionAttributes" class="headerlink" title="8.@SessionAttributes"></a><code>8.@SessionAttributes</code></h5><h5 id="9-SessionAttribute"><a href="#9-SessionAttribute" class="headerlink" title="9.@SessionAttribute"></a><code>9.@SessionAttribute</code></h5><h5 id="10-RequestAttribute"><a href="#10-RequestAttribute" class="headerlink" title="10.@RequestAttribute"></a><code>10.@RequestAttribute</code></h5><h5 id="11-Redirect-Attributes-重定向属性"><a href="#11-Redirect-Attributes-重定向属性" class="headerlink" title="11.Redirect Attributes/重定向属性"></a>11.Redirect Attributes/重定向属性</h5><ul>
<li>默认情况下，所有模型属性都被视为重定向URL中的URI模板变量。其余的属性中，那些是基元类型或基元类型的集合或数组的属性将自动附加为查询参数。</li>
<li>如果模型实例是专门为重定向准备的，则将基元类型属性作为查询参数追加可能是所需的结果。但是，在带注释的控制器中，模型可以包含为渲染目的添加的其他属性（例如，下拉字段值）。为了避免在URL中出现这样的属性，@RequestMapping方法可以声明一个类型为RedirectAttributes的参数，并使用它指定可用于RedirectView的确切属性。如果方法确实重定向，则使用RedirectAttributes的内容。否则，将使用模型的内容。</li>
<li>RequestMappingHandlerAdapter提供了一个名为ignoreDefaultModelOnRedirect的标志，您可以使用该标志指示如果控制器方法重定向，则不应使用默认模型的内容。相反，controller方法应该声明一个类型为RedirectAttributes的属性，或者，如果它没有这样做，则不应该将任何属性传递给RedirectView。MVC名称空间和MVC Java配置都将此标志设置为false，以保持向后兼容性。但是，对于新应用程序，我们建议将其设置为true。</li>
<li>请注意，当前请求中的URI模板变量在展开重定向URL时自动可用，您不需要通过Model或RedirectAttributes显式添加它们。下面的示例演示如何定义重定向：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/files/&#123;path&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:files/&#123;path&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Another way</span><br></pre></td></tr></table></figure>

<p>将数据传递到重定向目标的另一种方法是使用flash属性。与其他重定向属性不同，flash属性保存在HTTP会话中（因此不会出现在URL中）。有关详细信息，请参见Flash属性。</p>
<h5 id="12-Flash-Attributes"><a href="#12-Flash-Attributes" class="headerlink" title="12.Flash Attributes"></a>12.Flash Attributes</h5><ul>
<li>Flash属性为一个请求提供了一种方法来存储打算在另一个请求中使用的属性。这是重定向 - 时最常用的方法，例如，Post Redirect Get模式。Flash属性在重定向之前（通常在会话中）被临时保存，以便在重定向之后对请求可用，并立即被删除。</li>
<li>Spring MVC有两个主要的抽象来支持flash属性。FlashMap用于保存flash属性，而FlashMapManager用于存储、检索和管理FlashMap实例。</li>
<li>Flash属性支持始终为“on”，不需要显式启用。但是，如果不使用，它永远不会导致创建HTTP会话。对于每个请求，都有一个“input”FlashMap，其中包含从上一个请求（如果有的话）传递的属性，还有一个“output”FlashMap，其中包含要为后续请求保存的属性。这两个FlashMap实例都可以从Spring MVC的任何地方通过requestcontexttils中的静态方法访问。</li>
<li>带注释的控制器通常不需要直接使用FlashMap。相反，@RequestMapping方法可以接受redirect attributes类型的参数，并使用它为重定向场景添加flash属性。通过RedirectAttributes添加的Flash属性会自动传播到“output”FlashMap。类似地，重定向之后，“input”FlashMap中的属性会自动添加到为目标URL服务的控制器模型中。</li>
</ul>
<blockquote>
<p><strong>将请求与flash属性匹配</strong></p>
<p>flash属性的概念存在于许多其他web框架中，并被证明有时会暴露在并发性问题中。这是因为，根据定义，flash属性将存储到下一个请求。但是，“下一个”请求可能不是预期的接收者，而是另一个异步请求（例如，轮询或资源请求），在这种情况下，flash属性被过早删除。</p>
<p>为了减少此类问题的可能性，RedirectView会使用目标重定向URL的路径和查询参数自动“标记”FlashMap实例。反过来，默认的FlashMapManager在查找“input”FlashMap时会将该信息与传入的请求相匹配。</p>
<p>这并不能完全消除并发问题的可能性，但是通过重定向URL中已有的信息可以大大降低并发问题的可能性。因此，我们建议您主要在重定向场景中使用flash属性。</p>
</blockquote>
<h5 id="13-Multipart"><a href="#13-Multipart" class="headerlink" title="13.Multipart"></a>13.Multipart</h5><p>启用MultipartResolver后，将解析带有multipart/form数据的POST请求的内容，并将其作为常规请求参数进行访问。以下示例访问一个常规表单字段和一个上载文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/form"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFormUpload</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file) </span>&#123;<span class="comment">//将参数类型声明为List&lt;MultipartFile&gt;允许解析同一参数名的多个文件。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">            <span class="comment">// store the bytes somewhere</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:uploadSuccess"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:uploadFailure"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当@RequestParam注释声明为Map&lt;String，MultipartFile&gt;或MultiValueMap&lt;String，MultipartFile&gt;时，如果没有在注释中指定参数名，则会使用MultipartFile的参数名填充映射。</p>
</blockquote>
<blockquote>
<p>对于Servlet3.0多部分解析，您还可以使用javax.Servlet.http.Part代替Spring的MultipartFile，声明方法参数或集合值类型。</p>
</blockquote>
<p>您还可以将多部分内容用作到命令对象的数据绑定的一部分。例如，上例中的表单字段和文件可以是表单对象上的字段，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MultipartFile file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/form"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFormUpload</span><span class="params">(MyForm form, BindingResult errors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!form.getFile().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = form.getFile().getBytes();</span><br><span class="line">            <span class="comment">// store the bytes somewhere</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:uploadSuccess"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:uploadFailure"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在RESTful服务场景中，也可以从非浏览器客户端提交多部分请求。以下示例显示了一个带有JSON数据的文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /someUrl</span><br><span class="line">Content-Type: multipart/mixed</span><br><span class="line"></span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name="meta-data"</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"value"</span></span><br><span class="line">&#125;</span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name="file-data"; filename="file.properties"</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">... File Data ...</span><br></pre></td></tr></table></figure>

<p>您可以使用@RequestParam作为字符串访问“元数据”部分，但您可能希望它从JSON反序列化（类似于@RequestBody）。使用HttpMessageConverter转换多部分后，使用@RequestPart注释访问该多部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(@RequestPart(<span class="string">"meta-data"</span>)</span> MetaData metadata,</span></span><br><span class="line"><span class="function">        @<span class="title">RequestPart</span><span class="params">(<span class="string">"file-data"</span>)</span> MultipartFile file) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以将@RequestPart与javax.validation.Valid结合使用，也可以使用Spring的@Validated注释，这两种注释都会应用标准Bean验证。默认情况下，验证错误会导致MethodArgumentNotValidException，该异常将转换为400（错误的请求）响应。或者，可以通过errors或BindingResult参数在控制器内本地处理验证错误，如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@Valid @RequestPart(&quot;meta-data&quot;) MetaData metadata,</span><br><span class="line">        BindingResult result) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14-RequestBody"><a href="#14-RequestBody" class="headerlink" title="14.@RequestBody"></a>14.<code>@RequestBody</code></h5><p>可以使用@RequestBody注释通过HttpMessageConverter将请求体读取并反序列化为对象。以下示例使用@RequestBody参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/accounts"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(@RequestBody Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用MVC配置的消息转换器选项来配置或自定义消息转换。</p>
<p>可以将@RequestBody与javax.validation.Valid或Spring的@Validated注释结合使用，这两种方法都会应用标准Bean验证。默认情况下，验证错误会导致MethodArgumentNotValidException，该异常将转换为400（错误的请求）响应。或者，可以通过errors或BindingResult参数在控制器内本地处理验证错误，如下例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/accounts"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(@Valid @RequestBody Account account, BindingResult result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15-HttpEntity"><a href="#15-HttpEntity" class="headerlink" title="15.HttpEntity"></a>15.HttpEntity</h5><p>HttpEntity或多或少与使用@RequestBody相同，但它基于公开请求头和主体的容器对象。下面的列表显示了一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/accounts"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpEntity&lt;Account&gt; entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="16-ResponseBody"><a href="#16-ResponseBody" class="headerlink" title="16.@ResponseBody"></a>16.@ResponseBody</h5><p>可以对方法使用@ResponseBody注释，通过HttpMessageConverter将其序列化结果返回到响应体。下面的列表显示了一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/accounts/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@ResponseBody可以在类级别使用，在这种情况下，它由所有控制器方法继承。这就是@RestController，一个@Controller和@ResponseBody的组合注释。</p>
<ol>
<li>可以将@ResponseBody与反应类型【reactive types】一起使用。有关更多详细信息，请参阅异步请求和响应类型。</li>
<li>可以使用MVC配置的消息转换器选项来配置或自定义消息转换。</li>
<li>可以将@ResponseBody方法与JSON序列化视图结合起来。有关详细信息，请参见Jackson JSON。</li>
</ol>
<h5 id="17-ResponseEntity"><a href="#17-ResponseEntity" class="headerlink" title="17.ResponseEntity"></a>17.ResponseEntity</h5><p>ResponseEntity类似于@ResponseBody，但带有状态和标题。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/something"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String body = ... ;</span><br><span class="line">    String etag = ... ;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok().eTag(etag).build(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring MVC支持使用单值反应类型 异步生成响应，和/或为主体生成单值和多值反应类型。</p>
<h5 id="18-Jackson-JSON"><a href="#18-Jackson-JSON" class="headerlink" title="18.Jackson JSON"></a>18.Jackson JSON</h5><blockquote>
<p>Spring提供了对Jackson JSON库的支持。</p>
</blockquote>
<h6 id="18-1-JSON-Views"><a href="#18-1-JSON-Views" class="headerlink" title="18.1 JSON Views"></a>18.1 JSON Views</h6><p>Spring MVC为Jackson的序列化视图提供了内置支持，它只允许呈现对象中所有字段的子集。要将其与@ResponseBody或ResponseEntity控制器方法一起使用，可以使用Jackson的@JsonView注释激活序列化视图类，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="meta">@JsonView</span>(User.WithoutPasswordView<span class="class">.<span class="keyword">class</span>)//使用<span class="title">Jackson</span>的@<span class="title">JsonView</span>注释激活序列化视图类</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">User</span> <span class="title">getUser</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"eric"</span>, <span class="string">"7!jd#h23"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithoutPasswordView</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithPasswordView</span> <span class="keyword">extends</span> <span class="title">WithoutPasswordView</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonView</span>(WithoutPasswordView<span class="class">.<span class="keyword">class</span>)//使用<span class="title">Jackson</span>的@<span class="title">JsonView</span>注释激活序列化视图类</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">getUsername</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonView</span>(WithPasswordView<span class="class">.<span class="keyword">class</span>)//使用<span class="title">Jackson</span>的@<span class="title">JsonView</span>注释激活序列化视图类</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">getPassword</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@JsonView允许视图类数组，但每个控制器方法只能指定一个。如果需要激活多个视图，可以使用复合界面。</p>
</blockquote>
<p>对于依赖视图解析的控制器，可以将<strong>序列化视图类添加到模型</strong>中，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">AbstractController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, <span class="keyword">new</span> User(<span class="string">"eric"</span>, <span class="string">"7!jd#h23"</span>));</span><br><span class="line">        <span class="comment">//对于依赖视图解析的控制器，可以将**序列化视图类添加到模型**中</span></span><br><span class="line">        model.addAttribute(JsonView<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">User</span>.<span class="title">WithoutPasswordView</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"userView"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-3-4-Model"><a href="#1-3-4-Model" class="headerlink" title="1.3.4. Model"></a>1.3.4. Model</h4><p><strong>可以使用@ModeltAttribute注释：</strong></p>
<ol>
<li>在@RequestMapping方法中的方法参数上<strong>创建或访问模型中的对象</strong>，并通过WebDataBinder将其<strong>绑定</strong>到请求。</li>
<li>作为@Controller或@ControllerAdvice类中的方法级注释，有助于在调用任何@RequestMapping方法之前<strong>初始化模型</strong>。</li>
<li>在@RequestMapping方法上，标记其返回值的是一个<strong>model属性</strong>。</li>
</ol>
<p>本节讨论前面列表中的第二项@ModelAttribute methods。</p>
<p>@ModelAttribute方法也可以通过<strong>@ControllerAdvice在控制器之间共享</strong>。有关更多详细信息，请参阅控制器建议部分。<br>@ModelAttribute方法具有灵活的方法签名。除了@ModeltAttribute本身或任何与请求体相关的参数, 它们支持许多与@RequestMapping方法相同的参数<br>以下示例显示@ModelAttribute方法：</p>
<ul>
<li><p>控制器可以有任意数量的@ModelAttribute方法。所有这些方法都在同一控制器中的@RequestMapping方法之前调用。@ModelAttribute方法也可以通过@ControllerAdvice在控制器之间共享。有关更多详细信息，请参阅控制器建议部分。</p>
</li>
<li><p>@ModelAttribute方法具有灵活的方法签名。除了@modeltattribute本身或任何与请求体相关的参数。，它们还支持许多与@RequestMapping方法相同的参数。</p>
</li>
</ul>
<p>以下示例显示@ModelAttribute方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateModel</span><span class="params">(@RequestParam String number, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(accountRepository.findAccount(number));</span><br><span class="line">    <span class="comment">// add more ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例仅添加一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">addAccount</span><span class="params">(@RequestParam String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accountRepository.findAccount(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果未显式指定名称，则根据对象类型选择默认名称，如javadoc for Conventions中所述。始终可以通过使用重载的addAttribute方法或通过@ModeltAttribute上的name属性（返回值）指定显式名称。</p>
</blockquote>
<blockquote>
<p>还可以使用@ModeltAttribute作为@RequestMapping方法的方法级注释，在这种情况下，<strong>@RequestMapping方法的返回值被解释为模型属性</strong>。这通常不是必需的，因为这是HTML控制器中的默认行为，除非返回值是一个字符串，否则将被解释为视图名称。@ModelAttribute还可以自定义模型属性名称，如下例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/accounts/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"myAccount"</span>)<span class="comment">//@ModelAttribute还可以自定义模型属性名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> account;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-5-DataBinder"><a href="#1-3-5-DataBinder" class="headerlink" title="1.3.5. DataBinder"></a>1.3.5. <code>DataBinder</code></h4><p>@Controller或@ControllerAdvice类可以有@InitBinder方法来初始化WebDataBinder实例，而这些方法反过来又可以：</p>
<ol>
<li>将请求参数（即表单或查询数据）绑定到模型对象。</li>
<li>将基于字符串的请求值（例如请求参数、路径变量、头、cookies和其他）转换为控制器方法参数的目标类型。</li>
<li>在呈现HTML表单时，将模型对象值格式化为字符串值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span> <span class="comment">//Defining an @InitBinder method.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">        binder.registerCustomEditor(Date<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">CustomDateEditor</span>(<span class="title">dateFormat</span>, <span class="title">false</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span> <span class="comment">//在自定义格式化程序上定义@InitBinder方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        binder.addCustomFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-3-6-Exceptions"><a href="#1-3-6-Exceptions" class="headerlink" title="1.3.6. Exceptions"></a>1.3.6. Exceptions</h4><p>@Controller和@ControllerAdvice类可以有@ExceptionHandler方法来处理来自Controller方法的异常，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">(IOException ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，注释声明可以缩小要匹配的异常类型的范围，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;FileSystemException<span class="class">.<span class="keyword">class</span>, <span class="title">RemoteException</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">String</span>&gt; <span class="title">handle</span>(<span class="title">IOException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您甚至可以使用具有通用的参数签名的特定异常类型，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;FileSystemException<span class="class">.<span class="keyword">class</span>, <span class="title">RemoteException</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">String</span>&gt; <span class="title">handle</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-7-Controller-Advice"><a href="#1-3-7-Controller-Advice" class="headerlink" title="1.3.7. Controller Advice"></a>1.3.7. Controller Advice</h4><p>通常，@ExceptionHandler、@InitBinder和@ModelAttribute方法应用于声明它们的@Controller类（或类层次结构）中。如果您希望这些方法在全局范围内（跨控制器）应用得更多，可以在用@ControllerAdvice或@RestControllerAdvice注释的类中声明它们。</p>
<ul>
<li>@ControllerAdvice用@Component注释，这意味着可以通过组件扫描将这些类注册为springbean。</li>
<li>@RestControllerAdvice是一个组合注释，它使用@ControllerAdvice和@ResponseBody进行注释，这实际上意味着@ExceptionHandler方法通过消息转换（相对于视图解析或模板呈现）呈现到响应体。</li>
<li>启动时，@RequestMapping和@ExceptionHandler方法的基础结构类会检测用@ControllerAdvice注释的springbean，然后在运行时应用它们的方法。全局@ExceptionHandler方法（来自@ControllerAdvice）在本地方法（来自@Controller）之后应用。相反，全局@ModelAttribute和@InitBinder方法在本地方法之前应用。</li>
</ul>
<p>默认情况下，@ControllerAdvice方法应用于每个请求（即，所有控制器），但您可以使用注解上的属性将其缩小到控制器的子集，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target all Controllers annotated with @RestController</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>(annotations = RestController<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ExampleAdvice1</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target all Controllers within specific packages</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>(<span class="string">"org.example.controllers"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAdvice2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target all Controllers assignable to specific classes</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>(assignableTypes = &#123;ControllerInterface<span class="class">.<span class="keyword">class</span>, <span class="title">AbstractController</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ExampleAdvice3</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-Functional-Endpoints"><a href="#1-4-Functional-Endpoints" class="headerlink" title="1.4. Functional Endpoints"></a>1.4. Functional Endpoints</h3><h3 id="1-10-View-Technologies"><a href="#1-10-View-Technologies" class="headerlink" title="1.10. View Technologies"></a>1.10. View Technologies</h3><blockquote>
<p>在Spring MVC中使用视图技术是可插入的，无论您决定使用Thymeleaf、Groovy标记模板、jsp还是其他技术，这主要取决于配置更改。本章介绍与Spring MVC集成的视图技术。我们假设您已经熟悉视图分辨率。</p>
</blockquote>
<h4 id="1-10-1-Thymeleaf"><a href="#1-10-1-Thymeleaf" class="headerlink" title="1.10.1. Thymeleaf"></a>1.10.1. Thymeleaf</h4><blockquote>
<p>Thymeleaf是一个现代的服务器端Java模板引擎，它提倡通过双击在浏览器中预览自然HTML模板，这对于在不需要运行服务器的情况下独立处理UI模板（例如，由设计器）非常有帮助。Thymeleaf提供了一组最广泛的功能，去转换jsp页面。有关更完整的介绍，请参见Thymeleaf项目主页。</p>
<p>Thymeleaf与Spring MVC的集成由Thymeleaf项目管理。该配置涉及几个bean声明，如<strong>ServletContextTemplateResolver、SpringTemplateEngine和ThymeleafViewResolver</strong>。有关更多详细信息，请参见Thymeleaf+Spring。</p>
</blockquote>
<h4 id="1-10-2-FreeMarker"><a href="#1-10-2-FreeMarker" class="headerlink" title="1.10.2. FreeMarker"></a>1.10.2. FreeMarker</h4><h5 id="Form-Handling"><a href="#Form-Handling" class="headerlink" title="Form Handling"></a>Form Handling</h5><p>如果希望应用程序通过内部代码（例如）处理城市，则可以使用适当的键创建代码映射，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Map&lt;String, ?&gt; referenceData(HttpServletRequest request) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Map&lt;String, String&gt; cityMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    cityMap.put(<span class="string">"LDN"</span>, <span class="string">"London"</span>);</span><br><span class="line">    cityMap.put(<span class="string">"PRS"</span>, <span class="string">"Paris"</span>);</span><br><span class="line">    cityMap.put(<span class="string">"NYC"</span>, <span class="string">"New York"</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    model.put(<span class="string">"cityMap"</span>, cityMap);</span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







































<h3 id="HTTP-协议中-URI-和-URL-有什么区别？"><a href="#HTTP-协议中-URI-和-URL-有什么区别？" class="headerlink" title="HTTP 协议中 URI 和 URL 有什么区别？"></a>HTTP 协议中 URI 和 URL 有什么区别？</h3><p><strong>URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL</strong></p>
<ul>
<li>URI = Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。</li>
<li>URL = Universal Resource Locator 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol、host、port、path、parameter、anchor。</li>
<li>URN = Universal Resource Name 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。</li>
</ul>
<blockquote>
<p>假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。<br>而URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI。</p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">ETIQUETADO EN</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/SpringMVC/" rel="tag">SpringMVC</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">ANTERIOR</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/07/22/%E6%B5%8B%E8%AF%95/"
                    data-tooltip="测试"
                    aria-label="SIGUIENTE: 测试"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">SIGUIENTE</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
                    title="Compartir en Facebook"
                    aria-label="Compartir en Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
                    title="Compartir en Twitter"
                    aria-label="Compartir en Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
                    title="Compartir en Google+"
                    aria-label="Compartir en Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 Yuttts. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">ANTERIOR</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/07/22/%E6%B5%8B%E8%AF%95/"
                    data-tooltip="测试"
                    aria-label="SIGUIENTE: 测试"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">SIGUIENTE</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
                    title="Compartir en Facebook"
                    aria-label="Compartir en Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
                    title="Compartir en Twitter"
                    aria-label="Compartir en Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
                    title="Compartir en Google+"
                    aria-label="Compartir en Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
                        aria-label="Compartir en Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Compartir en Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
                        aria-label="Compartir en Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Compartir en Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://yuttts.github.io/2020/07/22/Spring%20MVC5.2.5%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
                        aria-label="Compartir en Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Compartir en Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Yuttts</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
